!                    *******************
                     PROGRAM PARTEL_PARA
!                    *******************
!
!***********************************************************************
! PARALLEL   V6P2                                   20/02/2012
!***********************************************************************
!
!brief    PREPROCESSING STEP BEFORE A PARALLEL COMPUTATION
!history   R. KOPMANN (BAW)
!+
!+
!+         FIRST  VERSION JANUARY-MARCH 2000
!
!history   JAJ
!+      12/12/2000
!+      SECOND VERSION PINXIT
!+     PARTITIONING OF GEOMETRY AND 2D RESULT FILES POSSIBLE

!history   JAJ
!+      22/02/2002
!+      THIRD VERSION
!+     ERRORS IN BC VALUES IN DECOMPOSED BC FILES REMOVED
!+     ERRONEOUS TREATMENT OF ISLANDS DEBUGGED
!
!history   J-M HERVOUET ; JAJ
!+      17/04/2002
!+     FOURTH VERSION
!+     PARTITIONING FOR 3D RESULT FILES DONE BY JMH
!+     INCLUDING BOTH PARTITIONING METHODS AND BEAUTIFYING BY JAJ
!
!history  J-M HERVOUET
!+     21/01/2003
!+     FIFTH VERSION
!+     CORRECTED A WRONG DIMENSION OF THE ARRAY CUT, AN ERROR
!+     OCCURING BY A LARGER NUMBER OF PROCESSORS
!
!history  JAJ; MATTHIEU GONZALES DE LINARES
!+        27/01/2003
!+        SIXTH VERSION
!+    CORRECTED A WRONG DIMENSION OF THE ARRAY ALLVAR
!
!history  J-M HERVOUET
!+       12/03/2003
!+      SEVENTH VERSION
!+      ALGORITHM CHANGED : A SEGMENT IS IN A SUBDOMAIN IF IT BELONGS
!+      TO AN ELEMENT IN THE SUBDOMAIN NOT IF THE 2 POINTS OF THE
!+      SEGMENT BELONG TO THE SUBDOMAIN.
!+       SPECIFIC ELEBD INCLUDED, ALL REFERENCE TO MPI OR BIEF REMOVED
!
!history  J-M HERVOUET
!+        01/09/2003
!+      EIGHTH VERSION
!+      UBOR AND VBOR INVERTED LINE 613 WHEN READING THE CLI FILE.
!
!history   C. MOULINEC, P. VEZOLLE, O. BOITEAU
!+
!+      NEXT VERSION
!+      SOME CHANGES
!
!history   C. DENIS (EDF-SINETICS)
!+        31/05/2010
!+      V6P2
!+      FURTHER DEVELOPPED IN ORDER TO DECREASE THE AMOOUT OF MEMORY
!
!history  N.DURAND (HRW), S.E.BOURBAN (HRW)
!+        21/02/2012
!+        V6P2
!+   Creation of DOXYGEN tags for automated documentation and
!+   cross-referencing of the FORTRAN sources
!
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
      IMPLICIT NONE
!
      INCLUDE 'mpif.h'
!
!   MAXIMUM GEOMETRICAL MULTIPLICITY OF A NODE (VARIABLE AUSSI
!   PRESENTE DANS LA BIEF, NE PAS CHANGER L'UNE SANS L'AUTRE)
      INTEGER, PARAMETER :: NBMAXNSHARE =  10
!
      ! MAX PARTITION NUMBER [00000..99999]
      INTEGER, PARAMETER :: MAXNPROC = 100000
      ! SOFT MAX FILE NAME LENGTH
      INTEGER, PARAMETER :: MAXLENSOFT = 144
      ! HARD MAX FILE NAME LENGTH
      INTEGER, PARAMETER :: MAXLENHARD = 250
      ! MAX ADDED SUFFIX LENGTH
      INTEGER, PARAMETER :: MAXADDCH = 10
      ! MAX NUMBER OF VARIABLES
      INTEGER, PARAMETER :: MAXVAR = 100
      ! MAXVAR*32 FOR ALLVAR
      INTEGER, PARAMETER :: MAXALLVARLENGTH = 3200
!
      INTEGER PMETHOD
      INTEGER NVAR, NREC, NPLAN, NPTFR, NPTIR, NPTFRMAX
      INTEGER NELEM, NPOIN, NDP, NELEM2, NPOIN2, NDUM
      INTEGER FILE_MPI
      INTEGER IB(10)
!
      INTEGER, ALLOCATABLE :: IKLES(:), IKLES_P(:)
      INTEGER, ALLOCATABLE :: IKLES3D(:),IKLES3D_P(:,:,:)
      INTEGER, ALLOCATABLE :: IRAND(:), IRAND_P(:)
      INTEGER, ALLOCATABLE :: LIHBOR(:), LIUBOR(:), LIVBOR(:)
      INTEGER, ALLOCATABLE :: LITBOR(:)
      INTEGER ::  NPOIN_P, NELEM_P , NPTFR_P,NPTIR_P
      INTEGER, ALLOCATABLE :: NBOR(:), NBOR_P(:)
      INTEGER, ALLOCATABLE :: NUMLIQ(:), NUMSOL(:)
      INTEGER, ALLOCATABLE :: KNOLG(:), KNOGL(:),CHECK(:)
      INTEGER, ALLOCATABLE :: ELELG(:), ELEGL(:)
      INTEGER, ALLOCATABLE :: CUT(:), CUT_P(:), SORT(:)
      INTEGER, ALLOCATABLE :: PART_P(:,:), PART(:),PART_P1(:,:)
!
      REAL, ALLOCATABLE    :: F(:,:), F_P(:,:)
      REAL, ALLOCATABLE    :: HBOR(:)
      REAL, ALLOCATABLE    :: UBOR(:), VBOR(:), AUBOR(:)
      REAL, ALLOCATABLE    :: TBOR(:), ATBOR(:), BTBOR(:)
!
      REAL TIMES, TIMED
!
      INTEGER :: NINP=10, NCLI=11, NMET=12,NINPFORMAT=52
      INTEGER :: NEPART=15, NNPART=16, NOUT=17, NCLM=18
      INTEGER TIME(3), DATE(3)
!
      CHARACTER(LEN=80)  :: TITLE
      CHARACTER(LEN=32)  :: VARI, VARIABLE(MAXVAR)
      CHARACTER(LEN=MAXALLVARLENGTH) :: ALLVAR
      CHARACTER(LEN=MAXLENHARD)  :: NAMEINP, NAMECLI, NAMEOUT, NAMECLM,
     &     NAMECLMP,NAMEOUTP
      CHARACTER(LEN=MAXLENHARD)  :: NAMEMET,NAMEEPART,NAMENPART,
     &     NAMENINPFORMAT,NAMEOUTFORMA
      CHARACTER(LEN=5)   :: CHCH
      CHARACTER(LEN=15)  :: FMT4
!
      INTEGER MAX_NELEM_P, MIN_NELEM_P
      INTEGER  MAX_NPOIN_P,MAX_N_NEIGH
      INTEGER I, J, K, L , M, N, P, ERR, ISO, IDUM
      INTEGER ISTOP, ISTART, ISEG, II, ILOOP
      INTEGER I_LEN, I_S, I_SP, I_LENCLI, I_LENINP
      INTEGER IELEM_P, IPOIN_P, IPTFR_P
!
      REAL XSEG, YSEG, BAL, RDUM
      DOUBLE PRECISION AREA, X1, X2, X3, Y1, Y2, Y3
      LOGICAL IS, WRT, TIMECOUNT
!
!   METISOLOGY
!
      INTEGER NPARTS, ETYPE, NUMFLAG, EDGECUT
      INTEGER, ALLOCATABLE :: EPART(:), NPART(:)
      CHARACTER(LEN=10) FMT1, FMT2, FMT3, FMT5, FMT6
!
!   FOR CALLING FRONT2
!
      ! MAX NUMBER OF BOUNDARIES
      INTEGER, PARAMETER :: MAXFRO = 300
      INTEGER NFRLIQ, NFRSOL, DEBLIQ(MAXFRO), FINLIQ(MAXFRO)
      INTEGER DEBSOL(MAXFRO), FINSOL(MAXFRO)
      INTEGER, ALLOCATABLE :: DEJAVU(:), KP1BOR(:,:)
!
!   FOR CALLING BIEF MESH SUBROUTINES (TO BE OPTIMISED SOON):
!
      INTEGER, ALLOCATABLE :: IFABOR(:,:), IFANUM(:,:), NELBOR(:)
      INTEGER, ALLOCATABLE :: NULONE(:,:)
      INTEGER, ALLOCATABLE :: IKLE(:,:), IKLBOR(:,:), ISEGF(:)
      INTEGER, ALLOCATABLE :: IT1(:), IT2(:), IT3(:)
!
      INTEGER LNG,LU,LI
      COMMON /INFO/ LNG,LU
!
!   TIME MEASURING
!
      INTEGER  TDEB, TFIN, TDEBP, TFINP, TEMPS, PARSEC
      INTEGER  TDEB_GLOB, TFIN_GLOB
      INTEGER  TIME_IN_SECONDS
      EXTERNAL TIME_IN_SECONDS
!
!   PARTEL_PARA_EXTENS FUNCTION
!
      CHARACTER(LEN=11) :: PARTEL_PARA_EXTENS
      EXTERNAL PARTEL_PARA_EXTENS
!
!----------------------------------------------------------------------
!
!   JAJ NEW FOR PARALLEL CHARACTERISTICS ////
!   HALO ELEMENTS: THESE ADJACENT TO THE INTERFACE EDGES HAVING
!   NEIGHBOURS BEHIND A BOUNDARY
!
!   THE ELEMENTAL GLOBAL->LOCAL NUMBERING TRANSLATION TABLE
!   THIS IS ELEGL SAVED FROM ALL PARTITIONS FOR FURTHER USE
!
      DOUBLE PRECISION :: STARTTIME,ENDTIME,STARTIOTIME,STARTCTIME
      INTEGER, ALLOCATABLE :: GELEGL(:),GELEGL1(:)
!
      ! THE HALO ELEMENTS NEIGHBOURHOOD DESCRIPTION FOR A HALO CELL
      INTEGER, ALLOCATABLE :: IFAPAR(:,:)
!
      ! THE NUMBER OF HALO CELLS PRO PARTITION
      INTEGER :: NHALO
!
      ! WORK VARIABLES
      INTEGER IFALOC(3)
      INTEGER TEMP_I(8)
      DOUBLE PRECISION TEMP_F(9)
      LOGICAL FOUND
      INTEGER NDP_2D,NDP_3D,NB_INTER_GLOB,COMPT
      INTEGER EF,POS
      INTEGER, ALLOCATABLE :: NBRE_EF(:),NBRE_EF_LOC(:),EF_I(:),
     &     TAB_TMP(:),EF_II(:),GLOBAL_INTER_NODE_REORD(:)
      INTEGER, ALLOCATABLE :: PART_P_TMP1(:),PART_P_TMP2(:)
      LOGICAL TROUVE,HALO
      INTEGER NOEUD,NBRE_NOEUD_INTERNE
      INTEGER NBRE_NOEUD_INTERF
      INTEGER FRONTIERE, NBRE_EF_I,IER,ID,NBRE_NPTIR
      LOGICAL INTERFACE
      CHARACTER (LEN=5) :: III
!
!   FOR SCOTCH
!
!      DOUBLEPRECISION    GRAPH  (SCOTCH_GRAPHDIM)
!      DOUBLEPRECISION    STRADAT (SCOTCH_STRATDIM)
      INTEGER BASEVAL
      INTEGER VERTNBR
      INTEGER EDGENBR
      INTEGER, ALLOCATABLE :: VER (:)
      INTEGER, ALLOCATABLE :: EDGETAB (:)
      INTEGER DECOUP
      NDP_2D=3
      NDP_3D=6
      CALL MPI_INIT(IER)
      IF(IER.NE.0) THEN
         IF(LNG.EQ.1) WRITE(LU,*) 'P_INIT: ERREUR DANS MPI_INIT'
         IF(LNG.EQ.2) WRITE(LU,*) 'P_INIT: ERROR IN MPI_INIT'
         WRITE(LU,*) 'MPI ERROR ',IER
         STOP
      ENDIF
!
      CALL MPI_COMM_RANK(MPI_COMM_WORLD,ID,IER)
      IF(IER.NE.0) THEN
         IF(LNG.EQ.1) WRITE(LU,*) 'P_INIT: ERREUR DANS MPI_COMM_RANK'
         IF(LNG.EQ.2) WRITE(LU,*) 'P_INIT: ERROR IN MPI_COMM_RANK'
         WRITE(LU,*) 'MPI ERROR ',IER
         STOP
      ENDIF
!
!----------------------------------------------------------------------
!
      CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
      TIMECOUNT = .TRUE.
      IF (PARSEC==0) TIMECOUNT = .FALSE.  ! COUNT_RATE == 0 : NO CLOCK
      IF (TIMECOUNT) TDEB = TEMPS
!
      LNG=2    ! ENGLISH PLEASE
      LU=6     ! FORTRAN STANDARD OUPUT CHANNEL
      LI=5     ! FORTRAN STANDARD INPUT CHANNEL
!
!----------------------------------------------------------------------
!   INTRODUCE YOURSELF
!
      IF (ID .EQ. 0) THEN
!
         WRITE(LU,*) ' '
         WRITE(LU,*) '+----------------------------------------------+'
         WRITE(LU,*) ' '
         WRITE(LU,*) '  PARTEL //'
         WRITE(LU,*) '  PARALLEL VERSION DEVELOPPED BY'
         WRITE(LU,*) '  CHRISTOPHE DENIS (SINETICS)'
         WRITE(LU,*) ' '
         WRITE(LU,*) '  PARTEL'
         WRITE(LU,*) '  BUNDESANSTALT FUER WASSERBAU, KARLSRUHE'
         WRITE(LU,*) ' '
         WRITE(LU,*) '  METIS 4.0.3'
         WRITE(LU,*) '  REGENTS OF THE UNIVERSITY OF MINNESOTA'
         WRITE(LU,*) ' '
         WRITE(LU,*) '+----------------------------------------------+'
!
      END IF
!
!----------------------------------------------------------------------
!   NAMES OF THE INPUT FILES:
!
      INQUIRE (FILE='PARTEL.PAR',EXIST=IS)
      IF( .NOT.IS ) THEN
         WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') 'PARTEL.PAR'
         CALL PARTEL_PARA_PLANTE2(-1)
         STOP
      END IF
!
      OPEN(UNIT=74,FILE='PARTEL.PAR')
      READ(74,*) NAMEINP
      READ(74,*) NAMECLI
      READ(74,*) NPARTS
      READ(74,*) DECOUP
      ! SI DECOUP= 0 ON NE DECOUPE PAS AVEC METIS ON LIT UN FICHIER
      ! RESULT_SEQ_METIS CREE PAR PARTEL_PRELIM (OU AUTRE !!)
      ! SINON ON DECOUPE AVEC METIS
      CLOSE(74)
!
      INQUIRE (FILE=NAMEINP,EXIST=IS)
      IF( .NOT.IS ) THEN
         WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') NAMEINP
         CALL PARTEL_PARA_PLANTE2(-1)
         STOP
      END IF
!
      INQUIRE (FILE=NAMECLI,EXIST=IS)
      IF (.NOT.IS) THEN
         WRITE (LU,'('' FILE DOES NOT EXIST: '',A30)') NAMECLI
         CALL PARTEL_PARA_PLANTE2(-1)
         STOP
      END IF
!
      PMETHOD=1

      I_S  = LEN(NAMEINP)
      I_SP = I_S + 1
      DO I=1,I_S
        IF (NAMEINP(I_SP-I:I_SP-I) .NE. ' ') EXIT
      ENDDO
      I_LEN=I_SP - I
      I_LENINP = I_LEN
!
      IF (I_LENINP > MAXLENSOFT) THEN
          WRITE(LU,*) ' '
          WRITE(LU,*) 'ATTENTION:'
          WRITE(LU,*) 'THE NAME OF THE INPUT FILE:'
          WRITE(LU,*) NAMEINP
          WRITE(LU,*) 'IS LONGER THAN ',MAXLENSOFT,' CHARACTERS'
          WRITE(LU,*) 'WHICH IS THE LONGEST APPLICABLE NAME FOR TELEMAC'
          WRITE(LU,*) 'INPUT AND OUTPUT FILES. STOPPED. '
          CALL PARTEL_PARA_PLANTE2(-1)
          STOP
      ENDIF
!
      IF (ID .EQ. 0)  THEN
         STARTTIME=MPI_WTIME()
      END IF
      OPEN(NINP,FILE=NAMEINP,STATUS='OLD',FORM='UNFORMATTED')
      REWIND NINP

      READ (NINP) TITLE
      READ (NINP) I, J
      NVAR = I + J
      ALLVAR(1:41) = 'X-COORDINATE----M---,Y-COORDINATE----M---'
      ISTART = 42
      DO I=1,NVAR
         READ(NINP) VARI
         VARIABLE(I) = VARI
         DO J=1,32
            IF(VARI(J:J).EQ.' ') VARI(J:J) = '-'
         END DO
         ISTOP = ISTART+20
         IF (ISTOP.GT.MAXALLVARLENGTH) THEN
            WRITE(LU,*) 'VARIABLE NAMES TOO LONG FOR STRING ALLVAR'
            WRITE(LU,*) 'STOPPED.'
            CALL PARTEL_PARA_PLANTE2(-1)
            STOP
         ENDIF
         ALLVAR(ISTART:ISTART) = ','
         ALLVAR(ISTART+1:ISTOP) = VARI
         ISTART=ISTOP+1
      ENDDO
!
!   READ THE REST OF THE SELAFIN FILE
!   10 INTEGERS, THE FIRST IS THE NUMBER OF RECORDS (TIMESTEPS)
!
      READ (NINP) (IB(I), I=1,10)
      IF (IB(8).NE.0.OR.IB(9).NE.0) THEN
         WRITE(LU,*) 'THIS IS A PARTIAL OUTPUT FILE'
         WRITE(LU,*) 'MAYBE MEET GRETEL BEFORE...'
      ENDIF
      NREC  = IB(1)
      NPLAN = IB(7)
!
      IF (IB(10).EQ.1) THEN
         READ(NINP) DATE(1), DATE(2), DATE(3), TIME(1), TIME(2), TIME(3)
      ENDIF
!
      READ (NINP) NELEM,NPOIN,NDP,NDUM
      IF (NPLAN.GT.1) THEN
!
         NPOIN2 = NPOIN/NPLAN
         NELEM2 = NELEM/(NPLAN-1)
         IF (MOD(NPOIN,NPLAN).NE.0) THEN
            WRITE (LU,*) 'BUT NPOIN2 /= NPOIN3/NPLAN!'
            CALL PARTEL_PARA_PLANTE2(-1)
            STOP
         ENDIF
         IF (MOD(NELEM,(NPLAN-1)).NE.0) THEN
            WRITE (LU,*) 'BUT NELEM2 /= NELEM3/NPLAN!'
            CALL PARTEL_PARA_PLANTE2(-1)
            STOP
         ENDIF
      ELSE
!
         NPOIN2 = NPOIN
         NELEM2 = NELEM
      ENDIF
!
      IF (NDP.EQ.3) THEN
         WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 2D SELAFIN'
      ELSEIF (NDP.EQ.6) THEN
         WRITE(LU,*) 'THE INPUT FILE ASSUMED TO BE 3D SELAFIN'
      ELSE
!         WRITE(LU,*) 'THE ELEMENTS ARE NEITHER TRIANGLES NOR PRISMS!'
!         WRITE(LU,*) 'NDP = ',NDP
         CALL PARTEL_PARA_PLANTE2(-1)
         STOP
      ENDIF
!
!   NOW LET US ALLOCATE
!
      ALLOCATE (IKLES(NELEM2*3),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IKLES')
      IF(NPLAN.GT.1) THEN
         ALLOCATE (IKLES3D(NELEM*NDP),STAT=ERR)
         IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IKLES3D')
      ENDIF
      ALLOCATE (IRAND(NPOIN),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IRAND')
      ! NVAR+2 : FIRST TWO FUNCTIONS ARE X AND Y
      ! NPOIN IS 3D HERE IN 3D
      ALLOCATE (F(NPOIN,NVAR+2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IRAND')
!
!   CONNECTIVITY TABLE:
!
      IF(NPLAN.EQ.0) THEN
         READ(NINP) ((IKLES((K-1)*NDP+J),J=1,NDP),K=1,NELEM)
      ELSE
         READ(NINP) ((IKLES3D((K-1)*NDP+J),J=1,NDP),K=1,NELEM)
!        BUILDING IKLES
         DO J=1,3
            DO K=1,NELEM2
               IKLES((K-1)*3+J)=IKLES3D((K-1)*6+J)
            ENDDO
         ENDDO
      ENDIF
!
!   BOUNDARY NODES INDICATIONS
!
      READ(NINP) (IRAND(J),J=1,NPOIN)
!
!
      READ(NINP) (F(J,1),J=1,NPOIN)
      READ(NINP) (F(J,2),J=1,NPOIN)
!
      ILOOP = 0
!      DO
!
!   READ THE TIME STEP
!
         READ(NINP) TIMES
!         WRITE(NINPFORMAT,*) TIMES
         ILOOP = ILOOP + 1
!
         TIMED = TIMES/3600
!         WRITE(LU,*) 'TIMESTEP: ',TIMES,'S = ',TIMED,'H'
!
! READ THE TIME VARIABLES; NO 1 AND 2 ARE X,Y
!
         DO K=3,NVAR+2
!            WRITE(LU,*) 'NOW READING VARIABLE',K-2
            READ(NINP) (F(J,K), J=1,NPOIN)
!            WRITE(NINPFORMAT,*) (F(J,K), J=1,NPOIN)
!            WRITE(LU,*) 'READING VARIABLE',K-2,' SUCCESSFUL'
         END DO
!      END DO
!      STOP
 111  CLOSE (NINP)
      CALL MPI_BARRIER(MPI_COMM_WORLD,IER)
      IF (ID .EQ. 0) THEN
         STARTCTIME=MPI_WTIME()
         WRITE(LU,*) 'TEMPS LECTURE :',STARTCTIME-STARTTIME
      END IF

!      WRITE(LU,*) ' '
!      WRITE(LU,*) 'THERE HAS BEEN ',ILOOP,' TIME-DEPENDENT RECORDINGS'
!      WRITE(LU,*) 'ONLY THE LAST ONE TAKEN INTO CONSIDERATION'
!      WRITE(LU,*) ' '
!
!-----------------------------------------------------------------------
! ...CHECK IF THE AREA OF THE ELEMENTS ARE NEGATIVE...
! ... AREA = 0.5*ABS(X1*Y2 - Y1*X2 + Y1*X3 - X1*Y3 + X2*Y3 - Y2*X3)
!    NOTICE: AREA AND X1, Y1, X2, Y2, X3, Y3 MUST BE DOUBLE PRECISION
!
!        DO J=1,NELEM
!           X1 = F(IKLES((J-1)*3+1),1)
!           Y1 = F(IKLES((J-1)*3+1),2)
!           X2 = F(IKLES((J-1)*3+2),1)
!           Y2 = F(IKLES((J-1)*3+2),2)
!           X3 = F(IKLES((J-1)*3+3),1)
!           Y3 = F(IKLES((J-1)*3+3),2)
!           AREA = X1*Y2-Y1*X2+Y1*X3-X1*Y3+X2*Y3-Y2*X3
!           IF ( AREA < 0.0 ) THEN
!              WRITE(LU,*) 'GLOBAL DOMAIN'
!              WRITE(LU,*) 'DETERMINANT OF ELEMENT',J,' IS NEGATIVE'
!              WRITE(LU,*) '(LOCAL NODE ORIENTATION IS CLOCKWISE!)'
!              WRITE(LU,*) 'DET-VALUE: ',AREA
!              WRITE(LU,*) 'NODE NR 1, X1,Y1: ',IKLES((J-1)*3+1),X1,Y1
!              WRITE(LU,*) 'NODE NR 2, X2,Y2: ',IKLES((J-1)*3+2),X2,Y2
!              WRITE(LU,*) 'NODE NR 3, X3,Y3: ',IKLES((J-1)*3+3),X3,Y3
!              CALL PARTEL_PARA_PLANTE2(-1)
!              STOP
!           ENDIF
!        END DO
!
!----------------------------------------------------------------------
! READ THE BOUNDARY CONDITIONS FILE
!
!      WRITE(LU,*) ' '
!      WRITE(LU,*) '--------------------------'
!      WRITE(LU,*) '  BC FILE: ',NAMECLI
!      WRITE(LU,*) '--------------------------'
!      WRITE(LU,*) ' '
!
!   BUT ALLOCATE FIRST
!
      NPTFRMAX = NPOIN2   ! BETTER IDEA ?
!
      ALLOCATE (LIHBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'LIHBOR')
      ALLOCATE (LIUBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'LIUBOR')
      ALLOCATE (LIVBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'LIVBOR')
      ALLOCATE (HBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'HBOR')
      ALLOCATE (UBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'UBOR')
      ALLOCATE (VBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'VBOR')
      ALLOCATE (AUBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'AUBOR')
      ALLOCATE (TBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'TBOR')
      ALLOCATE (ATBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'ATBOR')
      ALLOCATE (BTBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'BTBOR')
      ALLOCATE (LITBOR(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'LITBOR')
      ALLOCATE (NBOR(2*NPTFRMAX),STAT=ERR)  ! FOR FRONT2
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NBOR')
      ALLOCATE (NUMLIQ(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NUMLIQ')
      ALLOCATE (NUMSOL(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NUMSOL')
      ALLOCATE (CHECK(NPTFRMAX),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'CHECK')
!
!   CORE NAME LENGTH
!
      I_S  = LEN(NAMECLI)
      I_SP = I_S + 1
      DO I=1,I_S
         IF (NAMECLI(I_SP-I:I_SP-I) .NE. ' ') EXIT
      ENDDO
      I_LEN=I_SP - I
      I_LENCLI = I_LEN
!
      IF (I_LENINP > MAXLENSOFT) THEN
         WRITE(LU,*) ' '
         WRITE(LU,*) 'ATTENTION:'
         WRITE(LU,*) 'THE NAME OF THE BOUNDARY CONDITIONS FILE:'
         WRITE(LU,*) NAMECLI
         WRITE(LU,*) 'IS LONGER THAN ',MAXLENSOFT,' CHARACTERS'
         WRITE(LU,*) 'WHICH IS THE LONGEST APPLICABLE NAME FOR TELEMAC '
         WRITE(LU,*) 'INPUT AND OUTPUT FILES. STOPPED. '
         CALL PARTEL_PARA_PLANTE2(-1)
         STOP
      ENDIF
!
      OPEN(NCLI,FILE=NAMECLI,STATUS='OLD',FORM='FORMATTED')
      REWIND NCLI
!
!   READING BOUNDARY FILE AND COUNTING BOUNDARY POINTS
!
      K=1
 900  CONTINUE
      READ(NCLI,*,END=901,ERR=901) LIHBOR(K),LIUBOR(K),
     &                             LIVBOR(K),
     &             HBOR(K),UBOR(K),VBOR(K),AUBOR(K),LITBOR(K),
     &             TBOR(K),ATBOR(K),BTBOR(K),NBOR(K),CHECK(K)
!
!   NOW CHECK IS THE BOUNDARY NODE COLOUR
!     IF(CHECK(K).NE.K) THEN
!        WRITE(LU,*) 'ERROR IN BOUNDARY CONDITIONS FILE AT LINE ',K
!        CALL PARTEL_PARA_PLANTE2(-1)
!        STOP
!     ENDIF
      K=K+1
      GOTO 900
 901  CONTINUE
      NPTFR = K-1
!     WRITE (LU,*) ' '
!      WRITE (LU,*) 'NUMBER OF BOUNDARY NODES IN 2D MESH: ',NPTFR
!      WRITE (LU,*) ' '
      CLOSE(NCLI)
!
!----------------------------------------------------------------------
!   NUMBERING OF OPEN BOUNDARIES
!   NUMBERING OF LIQUID BOUNDARY, IF 0 = SOLID
!   OPN: NUMBER OF OPEN BOUNDARY
!   IN ORDER TO DO IT IN THE SAME WAY AS TELEMAC DOES,
!   IT IS BEST TO CALL FRONT2 HERE
!
!   FOR CALLING BIEF MESH SUBROUTINES
!   CAN BE OPTIMISED / USES A LOT OF MEMORY
!   THE ONLY REASON IS TO OBTAIN KP1BOR AND NUMLIQ
!
      ALLOCATE (DEJAVU(NPTFR),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'DEJAVU')
      ALLOCATE (KP1BOR(NPTFR,2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'KP1BOR')
!JAJ----------V ////
!     CHANGED NELEM TO NELEM2, NDP TO 3 HUH!
!     CAUSING ERRORS WHEN 3D RESTART/REFERENCE FILES ARE PARTITIONED
!     AND BC FILE IS WRITTEN AGAIN (WHAT FOR, ACTUALLY???)
!     CAUSE: CALLING VOISIN WITH NELEM2 BUT IFABOR(NELEM=NELEM3,NDP=6)
      ALLOCATE (IFABOR(NELEM2,3),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IFABOR')
      ALLOCATE (IFANUM(NELEM2,3),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IFANUM')
      ALLOCATE (IKLBOR(NPTFR,2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IKLBOR')
      ALLOCATE (NELBOR(NPTFR),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NELBOR')
      ALLOCATE (NULONE(NPTFR,2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NULONE')
      ALLOCATE (ISEGF(NPTFR),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'ISEGF')
      ALLOCATE (IKLE(NELEM2,3),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IKLE')
      ALLOCATE (IT1(NPOIN),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IT1')
      ALLOCATE (IT2(NPOIN),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IT2')
      ALLOCATE (IT3(NPOIN),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IT3')
!
!   TRANSFORM IKLES--> IKLE FOR 2D ROUTINES  (AN OLD TELEMAC DISEASE)
!
      DO I = 1,3
         DO J  = 1,NELEM2
            IKLE(J,I) = IKLES((J-1)*3+I)
         ENDDO
      ENDDO
!
      CALL PARTEL_VOISIN(IFABOR, NELEM2, NELEM2, 11, IKLE, NELEM2,
     &                   NPOIN2, IT1, IT2)
!
!      WRITE(LU,'(/,'' CALLING ELEBD'')')
!
      CALL PARTEL_ELEBD (NELBOR, NULONE, KP1BOR, IFABOR, NBOR, IKLE,
     &                   NELEM2, IKLBOR, NELEM2, NELEM2, NPTFRMAX,
     &                   NPOIN2, NPTFR, 11, LIHBOR, 2, IFANUM,
     &                   1, ISEGF, IT1, IT2, IT3 )
!
!      WRITE(LU,'(/,'' BOUNDARY TYPE NUMBERING USING FRONT2'')')
!
      CALL PARTEL_FRONT2 (NFRLIQ,NFRSOL,DEBLIQ,FINLIQ,DEBSOL,FINSOL,
     &             LIHBOR,LIUBOR,F(1:NPOIN2,1),F(1:NPOIN2,2),
     &             NBOR,KP1BOR(1:NPTFR,1),DEJAVU,NPOIN2,NPTFR,
     &             2,.FALSE.,NUMLIQ,NUMSOL,NPTFRMAX)
!
      DEALLOCATE (DEJAVU)
!JAJ //// IFABOR APPLIED LATER FOR FINDING HALO CELL NEIGHBOURHOODS
!!!!      DEALLOCATE (IFABOR)
      DEALLOCATE (IFANUM)
      DEALLOCATE (IKLBOR)
!     DEALLOCATE (NELBOR)
      DEALLOCATE (NULONE)
      DEALLOCATE (ISEGF)
      DEALLOCATE (IKLE)
      DEALLOCATE (IT1)
      DEALLOCATE (IT2)
      DEALLOCATE (IT3)
!
!----------------------------------------------------------------------
!   OPEN AND REWRITE METIS SOFTWARE INPUT FILES
!   NOT NECESSARY IF VISUALISATION OR MANUAL DECOMPOSITIONS
!   ARE NOT REQUIRED
!
!      WRITE(LU,*) ' '
!      WRITE(LU,*) '---------------------------'
!      WRITE(LU,*) ' METIS & PMVIS INPUT FILES '
!      WRITE(LU,*) '---------------------------'
!      WRITE(LU,*) ' '
!
!!!      OPEN(NMET,FILE=NAMEMET,STATUS='UNKNOWN',FORM='FORMATTED')
!!!      REWIND NMET
!!!      WRITE(LU,*) 'INPUT FILE FOR PARTITIONING: ', NAMEMET
!
!   THE FIRST LINE IS NOT NECESSARY IN THE LATEST VERSION
!   WE WRITE THE FILES USING C CONVENTION
!
!   HERE THE IKLE 2D IS WRITTEN, EVEN IN 3D (HENCE NDP CONSIDERED TO BE 3)
!
!!!      WRITE(NMET,*) NELEM2,'1'
!!!      DO K=1,NELEM2
!!!        WRITE(NMET,'(3(I15,1X))') (IKLES((K-1)*3+J)-1, J=1,3)
!!!      END DO
!!!      CLOSE(NMET)
!
!   WRITE THE NODE COORDINATES FOR VISUALISATION
!   A CHECK FIRST...
!
!     WRITE (LU,'(/,'' AS COORDINATES FOR VISUALISATION TAKEN: '')')
!      WRITE (*,'(1X,A20)') ALLVAR(1:20)
!      WRITE (*,'(1X,A20)') ALLVAR(22:41)
!      WRITE (*,'(1X,A20)') ALLVAR(43:62)
!
!======================================================================
!   STEP 2 : PARTITIONING THE MESH
!
!   OTHER PARTITIONING METHODS SHOULD BE USED (SCOTCH FOR EXAMPLE)
!     ALL PROCESSORS PERFORM THIS TASK TO AVOID COMMUNICATION
!     THE USE OF PARMETIS OR PTSCOTCH COULD BE USED FOR LARGER MESHES
!     IF THERE WILL BE SOME MEMORY ALLOCATION PROBLEM
!======================================================================
C     WRITE(LU,*) ' '
!
      ALLOCATE (EPART(NELEM2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'EPART')
      ALLOCATE (NPART(NPOIN2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NPART')
!
      IF (NDP==3.OR.NDP==6) THEN
         ETYPE = 1
      ELSE
         WRITE(LU,*) 'METIS: IMPLEMENTED FOR TRIANGLES OR PRISMS ONLY'
         CALL PARTEL_PARA_PLANTE2(-1)
         STOP
      ENDIF
!
!   IMPORTANT: WE USE FORTRAN-LIKE FIELD ELEMENTS NUMBERING 1...N
!   IN C VERSION, 0...N-1 NUMBERING IS APPLIED!!!
!
      NUMFLAG = 1
!
      IF (TIMECOUNT) THEN
         CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
         TDEBP = TEMPS
      ENDIF
!
      IF (DECOUP .EQ. 0) THEN
         OPEN(UNIT=32,FILE='RESULT_SEQ_METIS')
         DO I=1,NELEM2
            READ(32,*) EPART(I)
         END DO
         CLOSE(32)
      ELSE
         CALL METIS_PARTMESHDUAL
     &        (NELEM2, NPOIN2, IKLES, ETYPE, NUMFLAG,
     &        NPARTS, EDGECUT, EPART, NPART)
      END IF
!
      IF (TIMECOUNT) THEN
         CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
         TFINP = TEMPS
         IF (ID .EQ. 0) THEN
         WRITE(LU,*) ' RUNTIME ',
     &            (1.0*(TFINP-TDEBP))/(1.0*PARSEC),' SECONDS'
      ENDIF
      ENDIF

!======================================================================
!   STEP 3 : ALLOCATE THE GLOBAL  ARRAYS NOT DEPENDING OF THE PARTITION
!
!======================================================================
!
!      KNOGL(I) =>  GLOBAL LABEL OF THE LOCAL POINT I
      ALLOCATE (KNOGL(NPOIN2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'KNOGL')
      KNOGL(:)=0

!   NBRE_EF(I) => NUMBER OF FINITE ELEMENT CONTAINING I
!   I IS A GLOBAL LABEL
      ALLOCATE (NBRE_EF(NPOIN2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NBRE_EF')
!
      IF(NPLAN.EQ.0) THEN
         ALLOCATE (F_P(NPOIN2,NVAR+2),STAT=ERR)
      ELSE
         ALLOCATE (F_P(NPOIN2*NPLAN,NVAR+2),STAT=ERR)
      ENDIF
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'F_P')
!
!      ALLOCATE (PART_P(NPOIN2,0:NPARTS),STAT=ERR)
!      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'PART_P')
!      PART_P(:,:)=0
!
!      ALLOCATE (PART_P1(NPOIN2,0:NPARTS),STAT=ERR)
!      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'PART_P1')
!      PART_P1(:,:)=0
!      WRITE(*,*) NELEM2,NPARTS
       ALLOCATE (GELEGL(NELEM2),STAT=ERR)
       IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'GELEGL')
       ALLOCATE (GELEGL1(NELEM2),STAT=ERR)
       IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'GELEGL1')
!
      ALLOCATE (SORT(NPOIN2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'CUT_P')
!
      ALLOCATE (CUT(NPOIN2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'CUT_P')
      SORT=0
!
      ALLOCATE(NBOR_P(NPOIN2),STAT=ERR)
      ALLOCATE(TAB_TMP( NBMAXNSHARE),STAT=ERR)
!
!======================================================================
!   STEP 4 : COMPUTE THE NUMBER OF FINITE ELEMENTS AND POINTS
!     BELONGING TO SUBMESH I
!
!======================================================================
!
!   FIRSTLY, ALL MPI PROCESSES  WORK ON THE WHOLE MESH
!     ----------------------------------------------
!
!   LOOP OVER THE FINITE ELEMENT OF THE MESH
!   TO COMPUTE THE NUMBER OF FINITE ELEMENTS CONTAINING EACH POINT NOEUD
      NBRE_EF(:)=0
      DO EF=1,NELEM2
         DO K=1,NDP_2D
            NOEUD=IKLES((EF-1)*3+K)
            NBRE_EF(NOEUD)=NBRE_EF(NOEUD)+1
         END DO
      END DO
!
!     THE PROCESS MPI ID  WORK ON THE SUBMESH ID+1
      I=ID+1
!
!   LOOP OVER THE FINITE ELEMENTD OF THE MESH TO COMPUTE
!   THE NUMBER OF THE FINITE ELEMENT AND POINTS BELONGING
!   TO SUBMESH I
!
      NELEM_P=0
      NPOIN_P=0
      DO EF=1,NELEM2
         IF (EPART(EF) .EQ. I) THEN
            NELEM_P=NELEM_P+1
            DO K=1,NDP_2D
               NOEUD=IKLES((EF-1)*3+K)
               IF (KNOGL(NOEUD) .EQ. 0) THEN
                  NPOIN_P=NPOIN_P+1
                  KNOGL(NOEUD)=NPOIN_P
               END IF
            END DO
         END IF
      END DO
!
!======================================================================
!     STEP 4 : ALLOCATION OF LOCAL ARRAYS NEEDED BY MPI PROCESSUS ID
!              WORKING ON SUBMESH ID+1
!======================================================================
!
!   ELEGL(E) => GLOBAL LABEL OF THE FINITE ELEMENT E
!   E IS THE LOCAL LABEL ON SUBMESH I
      ALLOCATE (ELELG(NELEM_P),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'ELELG')
      ELELG(:)=0
!   KNOLG(I) => GLOBAL LABEL OF THE POINT I
!   I IS THE LOCAL LABEL ON SUBDOMAIN I
      IF(NPLAN.EQ.0) THEN
         ALLOCATE (KNOLG(NPOIN_P),STAT=ERR)
      ELSE
         ALLOCATE (KNOLG(NPOIN_P*NPLAN),STAT=ERR)
      ENDIF
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'KNOLG')
      KNOLG(:)=0
!   NBRE_EF_LOC(I) : NUMBER OF FINITE ELEMENTS CONTAINING THE POINT I
!                    ON SUBMESH I
!   I IS THE LOCAL LABEL ON SUBMESH I
      ALLOCATE (NBRE_EF_LOC(NPOIN_P),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NBRE_EF_LOC')
!
!   EF_I(E) IS THE GLOBAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_I(NELEM_P),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'EF_I')
!   EF_II(E) IS THE LOCAL LABEL OF THE INTERFACE FINITE ELEMENT NUMBER E
      ALLOCATE (EF_II(NELEM_P),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'EF_II')
!
!======================================================================
!     STEP 5 : INITIALISATION  OF LOCAL ARRAYS
!                  (GELELG AND ELELG, NBRE_EF_LOC)
!
!======================================================================
!
      NELEM_P=0
      GELEGL(:)=0
      DO EF=1,NELEM2
         IF (EPART(EF) .EQ. I) THEN
            NELEM_P=NELEM_P+1
            ELELG(NELEM_P)=EF
            GELEGL(EF)=NELEM_P
         END IF
      END DO
      CALL MPI_ALLREDUCE(GELEGL,GELEGL1,NELEM2,MPI_INTEGER,
     &        MPI_SUM,
     &     MPI_COMM_WORLD,IER)
      DEALLOCATE(GELEGL)
      DEALLOCATE(NPART)
      NPTFR_P=0
      DO J=1,NPOIN_P
         NBRE_EF_LOC(J)=0
      END DO
!
!======================================================================
!     STEP 5 : COMPUTE THE NUMBER OF BOUNDARY AND INTERFACE POINTS
!              INITIALISATION OF NBRE_EF_LOC AND F_P
!
!======================================================================
!
      NPOIN_P=0
      NBRE_NOEUD_INTERNE=0
      NBRE_NOEUD_INTERF=0
!
      DO J=1,NELEM_P
         EF=ELELG(J)
         DO K=1,3
            NOEUD=IKLES((EF-1)*3+K)
            NBRE_EF_LOC(KNOGL(NOEUD))=NBRE_EF_LOC(KNOGL(NOEUD))+1
            IF (NBRE_EF_LOC(KNOGL(NOEUD)) .EQ. 1) THEN
!   THE POINT NOEUD IS ENCOUNTERED FOR THE FIRST TIME
               NPOIN_P=NPOIN_P+1
!   IS NOEUD A BOUNDARY POINT ?
               IF (IRAND(NOEUD) .NE. 0) THEN
                  NPTFR_P= NPTFR_P+1
               END IF
!   MODIFICATION OF   KNOGL ET F_P
               KNOLG(NPOIN_P)=NOEUD
               DO L=1,NVAR+2
                  F_P(NPOIN_P,L)=F(NOEUD,L)
               END DO
            END IF
!
!   NOEUD IS A INTERNAL POINT IF ALL FINITE ELEMENTS
!   CONTAINING IT BELONGS TO THE SAME SUBMESH
            IF (NBRE_EF_LOC(KNOGL(NOEUD)) .EQ. NBRE_EF(NOEUD)) THEN
               NBRE_NOEUD_INTERNE=NBRE_NOEUD_INTERNE+1
            END IF
         END DO
      END DO
!
!======================================================================
!     STEP 5 : FIND THE INTERFACES POINTS AND THE INTERFACE FINITE
!              ELEMENTS OF SUBMESH I
!======================================================================
!
!   COMPUTE THE NUMBER OF INTERFACES POINTS TO ALLOCATE CORRECLY  CUT_P
      NBRE_NPTIR=NPOIN_P-NBRE_NOEUD_INTERNE
      ALLOCATE (CUT_P(NBRE_NPTIR),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'CUT_P')
      NBRE_EF_I=0 ! THE NUMBER OF INTERFACE FINITE ELEMENT IS SET TO 0
      NPTIR_P=0 !THE NUMBER OF INTERFACE POINTS IS SET TO 0
!   LOOP ON THE FINITE ELEMENT BELONGING TO SUBMESH I
      DO J=1,NELEM_P
         INTERFACE=.FALSE.
         EF=ELELG(J)         ! GLOBAL LABEL OF THE FINITE ELEMENT
         DO K=1,NDP_2D       ! LOOP ON THE NODES CONTAINED IN EF
            NOEUD=IKLES((EF-1)*3+K)
            IF (ABS(NBRE_EF_LOC(KNOGL(NOEUD))) .NE. NBRE_EF(NOEUD))
     &         THEN
               ! THE GLOBAL NUMBER OF FINITE ELEMENTS CONTAINING NOEUD
               ! IS GREATER THAN THE LOCAL NUMBER OF FINITE ELEMENTS
               ! CONTAINING NOEUD => NOEUD IS AN INTERFACE POINT
               !    => EF IS AN INTERFACE FINITE ELEMENT
               INTERFACE=.TRUE.
            END IF
            IF (NBRE_EF_LOC(KNOGL(NOEUD)) .NE.  NBRE_EF(NOEUD).AND.
     &         NBRE_EF_LOC(KNOGL(NOEUD)) .GT. 0) THEN
               ! IT IS THE FIRST TIME THAT NOEUD IS DETECTED AS INTERFACE POINT
               ! AS AFTER  NBRE_EF_LOC(KNOGL(NOEUD))= -1*NBRE_EF_LOC(KNOGL(NOEUD))
               INTERFACE=.TRUE.
               NPTIR_P=NPTIR_P+1
               CUT_P(NPTIR_P)=NOEUD
!               PART_P(NOEUD,0)=PART_P(NOEUD,0)+1
               SORT(NOEUD)=1
!               IF (PART_P(NOEUD,0) > NBMAXNSHARE) THEN
!                  WRITE(LU,*)
!     &                 'AN INTERFACE NODE BELONGS TO ',
!     &                 'MORE THAN NBMAXNSHARE-1 SUBDOMAINS'
!                  CALL PARTEL_PARA_PLANTE2(-1)
!                  STOP
!               END IF
!               POS=PART_P(NOEUD,0)
!               PART_P(NOEUD,I)=I
               NBRE_EF_LOC(KNOGL(NOEUD))=
     &            -1*NBRE_EF_LOC(KNOGL(NOEUD))
            END IF
         END DO
         IF (INTERFACE .EQV. .TRUE.) THEN
            NBRE_EF_I=NBRE_EF_I+1
            EF_I(NBRE_EF_I)=EF
            EF_II(NBRE_EF_I)=J
         END IF
      END DO
      WRITE(22,*) 'NPTIR_P',NPTIR_P
      NB_INTER_GLOB=0
      ! IF (ID. EQ. 0) WRITE(89,*) SORT
      ! CUT=0
      CALL MPI_ALLREDUCE(SORT,CUT,NPOIN2,
     &        MPI_INTEGER,
     &        MPI_MAX,
     &        MPI_COMM_WORLD,IER)
!
      DO J=1,NPOIN2
         IF (CUT(J) .NE. 0) THEN
            NB_INTER_GLOB=NB_INTER_GLOB+1
         END IF
      END DO
      ALLOCATE(GLOBAL_INTER_NODE_REORD(NB_INTER_GLOB),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'GLOBAL_INTER_REORD')
      ALLOCATE(PART_P(NB_INTER_GLOB,NBMAXNSHARE+1),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'PART_P')
      ALLOCATE(PART_P_TMP1(NPARTS+1),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'PART_P_TMP1')
      ALLOCATE(PART_P_TMP2(NPARTS+1),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'PART_P_TMP2')
      NB_INTER_GLOB=0
      DO J=1,NPOIN2
         IF (CUT(J) .NE. 0) THEN
            NB_INTER_GLOB=NB_INTER_GLOB+1
            GLOBAL_INTER_NODE_REORD( NB_INTER_GLOB)=J
!            IF (NBRE_EF_LOC(KNOGL(NOEUD)) .LT. 0) THEN
!               PART_P(NB_INTER_GLOB,I)=I
!            END IF
         END IF
      END DO
      PART_P=0
      DO J=1,NB_INTER_GLOB
         PART_P_TMP1=0
         PART_P_TMP2=0
         COMPT=0
         NOEUD=GLOBAL_INTER_NODE_REORD(J)
         IF (SORT(NOEUD) .NE. 0) THEN
            PART_P_TMP1(I)=I
            PART_P_TMP1(NPARTS+1)=PART_P_TMP1(NPARTS+1)+1
         END IF
         CALL MPI_ALLREDUCE(PART_P_TMP1,PART_P_TMP2,NPARTS+1,
     &        MPI_INTEGER,
     &        MPI_SUM,
     &        MPI_COMM_WORLD,IER)
         DO K=1,NPARTS
            IF (PART_P_TMP2(K) .NE. 0 .AND. K .NE. I) THEN
               COMPT=COMPT+1
               PART_P(J,COMPT)=K
               PART_P(J,NBMAXNSHARE+1)=PART_P_TMP2(NPARTS+1)
            END IF
         END DO
      END DO
      DEALLOCATE(PART_P_TMP1)
      DEALLOCATE(PART_P_TMP2)
      DEALLOCATE(CUT)
      MAX_N_NEIGH=MAXVAL(PART_P(:,NBMAXNSHARE+1))
!      WRITE(LU,*) 'MAX', MAX_N_NEIGH
      IF ( MAX_N_NEIGH > NBMAXNSHARE-1 ) THEN
         WRITE(LU,*) 'SERIOUS WARNING: '
         WRITE(LU,*)
     &        'AN INTERFACE NODE BELONGS TO ',
     &        'MORE THAN NBMAXNSHARE-1 SUBDOMAINS'
         WRITE(LU,*) 'TELEMAC MAY PROTEST!'
      END IF
      IF (MAX_N_NEIGH > MAXNPROC) THEN
         WRITE (LU,*) 'THERE IS A NODE WHICH BELONGS TO MORE THAN ',
     &        MAXNPROC,' PROCESSORS, HOW COME?'
         CALL PARTEL_PARA_PLANTE2(-1)
          STOP
       ENDIF
       IF (MAX_N_NEIGH < NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
!
!======================================================================
!     STEP 6 : COMPUTE THE HALO
!
!======================================================================
!
       NHALO=0
!   LOOP ON THE INTERFACE FINITE ELEMENT
       DO J=1,NBRE_EF_I
          EF=EF_I(J)
          HALO=.FALSE.
          IFALOC(:)=IFABOR(EF,:)
          WHERE (IFALOC .GT. 0)
             IFALOC=EPART(IFALOC)
          END WHERE
          HALO=ANY(IFALOC .GT. 0 .AND. IFALOC .NE. I)
          IF (HALO .EQV. .TRUE.) THEN
             NHALO=NHALO+1
          END IF
       END DO
       ALLOCATE (IFAPAR(7,NHALO),STAT=ERR)
       IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IFAPAR')
       IFAPAR(:,:)=0
!
       NHALO=0
!   LOOP ON THE INTERFACE FINITE ELEMENT
       DO J=1,NBRE_EF_I
          EF=EF_I(J)
          HALO=.FALSE.
          IFALOC(:)=IFABOR(EF,:)
          WHERE (IFALOC .GT. 0)
             IFALOC=EPART(IFALOC)
          END WHERE
          HALO=ANY(IFALOC .GT. 0 .AND. IFALOC .NE. I)
          IF (HALO .EQV. .TRUE.) THEN
             NHALO=NHALO+1
             IFAPAR(1,NHALO)=EF_II(J)
             IFAPAR(2:4,NHALO)=IFALOC(:)
             IFAPAR(5:7,NHALO)=IFABOR(EF_I(J),:)
!             DO K=1,3
!                NPART(IFALOC(K))=NPART(IFALOC(K))+1
!             END DO
          END IF
       END DO
!
!       WRITE(LU,*) 'SOUS DOMAINE ',I,'NBRE POINTS',NPOIN_P,
!     &        'NBRE NOEUD INTE',NBRE_NOEUD_INTERNE,'INTERFACE',
!!     &        NPTIR_P,'NBRE FRONT',NPTFR_P, 'HALO',NHALO,
!     &        'NBRE_EFRONT',NBRE_EF_I
!
       IF (.NOT. ALLOCATED(NBOR_P)) THEN
          ALLOCATE(NBOR_P(NPOIN2),STAT=ERR)
          IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'NBOR_P')
       END IF
!       END DO

!       STOP
!       DO I=1,NPARTS
      CALL MPI_BARRIER(MPI_COMM_WORLD,IER)
      IF (ID .EQ. 0) THEN
         STARTIOTIME=MPI_WTIME()
         WRITE(LU,*) 'TEMPS CALCUL :',STARTIOTIME-STARTCTIME
      END IF
!
!-----------------------------------------------------------------------
!  THE CORE NAMES FOR THE OUTPUT BC FILES ACCORDING TO THE NUMBER OF PARTS
!
      NAMECLM = NAMECLI    ! CORE NAME LENGTH IS I_LENCLI
      NAMEOUT = NAMEINP    ! CORE NAME LENGTH IS I_LENINP
!
!----------------------------------------------------------------------
!
      NAMECLM(I_LENCLI+1:I_LENCLI+11) = PARTEL_PARA_EXTENS(NPARTS-1,ID)
!
      OPEN(NCLM,FILE=NAMECLM,
     &        STATUS='UNKNOWN',FORM='FORMATTED')
      REWIND(NCLM)
!
!   FILE OPENED, NOW WORK ON BOUNDARIES
! -----------------------------------
!
!   WHEN THE BOUNDARY NODE BELONGS TO THIS SUBDOMAIN IT WILL BE TAKEN
!   J IS THE RUNNING BOUNDARY NODE NUMBER
!
!      NPTIR = 0
      J = 0
!
      DO K=1,NPTFR
!
!   BOUNDARY NODES BELONGING TO THIS PARTITION
!
         IF ( KNOGL(NBOR(K)) /= 0) THEN
            J = J + 1
!            NBOR_P(J) = NBOR(K)
            ISEG = 0
            XSEG = 0.0
            YSEG = 0.0
!
!   IF THE ORIGINAL (GLOBAL) BOUNDARY LEADS FURTHER INTO
!   ANOTHER PARTITION THEN ISEG IS SET NOT EQUAL TO ZERO
!   THE NEXT NODE ALONG THE GLOBAL BOUNDARY HAS IPTFR = M
!   (BUT CHECK THE CASE THE CIRCLE CLOSES)
!
            M = KP1BOR(K,1)
!
!   NBOR_P CANNOT BE USED, IT IS NOT FULLY FILLED WITH DATA
!
            ISO = 0
!   MODIF JMH ON 10/03/2003 : CHECKING IF THE ADJACENT ELEMENT IS NOT IN THE
!                           SUB-DOMAIN
            IF (EPART(NELBOR(K)).NE.I) THEN
!   THIS WAS A TEST : IF NEXT BOUNDARY POINT NOT IN THE SUBDOMAIN
!   BUT IT CAN BE IN WHEREAS THE SEGMENT IS NOT.
!      IF ( KNOGL(NBOR(M)) == 0 ) THEN
!                  WRITE(LU,*)
!     &                 'GLOBAL BOUNDARY LEAVES @NODE (#G,#L): ',
!     &                 NBOR(K), KNOGL(NBOR(K)),
!     &                 ' --> (#G) ', NBOR(M)
!
            ISEG = NBOR(M)
            XSEG = F(ISEG,1)
            YSEG = F(ISEG,2)
C            NPTIR = NPTIR + 1
C            CUT(NPTIR) = IRAND_P(KNOGL(NBOR(K)))
             ISO = ISO + 1
            ENDIF
!
            M = KP1BOR(K,2)
!
!     MODIF JMH ON 10/03/2003 : SAME AS ABOVE, BUT PREVIOUS SEGMENT ,THUS M, NOT K
            IF (EPART(NELBOR(M)).NE.I) THEN
!     IF ( KNOGL(NBOR(M) ) == 0 ) THEN
!               WRITE(LU,*)
!     &              'GLOBAL BOUNDARY ENTERS @NODE (#G,#L): ',
!!     &              NBOR(K), KNOGL(NBOR(K)),
!     &              ' <-- (#G) ', NBOR(M)
!
               ISEG = -NBOR(M)
               XSEG = F(-ISEG,1)
               YSEG = F(-ISEG,2)
               ISO = ISO + 1
C               NPTIR = NPTIR + 1
C               CUT(NPTIR) = IRAND_P(KNOGL(NBOR(K)))
            ENDIF
!
!     WHEN BOTH NEIGHBOURS BOUNDARY NODES BELONG TO ANOTHER PARTITION
!
            IF (ISO == 2) THEN
               ISEG = -9999
               ISO = 0
!               WRITE(LU,*) 'ISOLATED BOUNDARY POINT',
!     &              NBOR(K), KNOGL(NBOR(K))
            ENDIF
!
            WRITE (NCLM,4000)
     &         LIHBOR(K), LIUBOR(K), LIVBOR(K),
     &         HBOR(K), UBOR(K), VBOR(K),
     &          AUBOR(K), LITBOR(K), TBOR(K), ATBOR(K), BTBOR(K),
!     JMH 16/06/2008: INITIAL LINE NUMBER OR COLOUR
     &          NBOR(K),CHECK(K), ISEG, XSEG, YSEG, NUMLIQ(K)
!     &          NBOR(K),    J   , ISEG, XSEG, YSEG, NUMLIQ(K)

!     19/10/2007 ER+JMH SUR RECOMMANDATION CHARLES MOULINEC
!     MAIS XSEG ET YSEG NE SONT PLUS UTILISES
 4000       FORMAT (1X,I2,1X,2(I1,1X),3(F24.12,1X),1X,
     &           F24.12,3X,I1,1X,3(F24.12,1X),1I15,1X,1I15,
     &           1X,I15,1X,2(F27.15,1X),I15)
         ENDIF
!
      END DO

      FMT4='(I15)'
      WRITE (NCLM,*) NPTIR_P
!      WRITE(LU,*) '######### ', NPTIR_P
      IF (MAX_N_NEIGH < NBMAXNSHARE-1) MAX_N_NEIGH = NBMAXNSHARE-1
      FMT4='(   (I15,1X))'
      WRITE (FMT4(2:4),'(I3)') MAX_N_NEIGH+1
!
      DO J=1, NB_INTER_GLOB
         NOEUD=GLOBAL_INTER_NODE_REORD(J)
         IF (SORT(NOEUD) .NE. 0) THEN

            WRITE(NCLM,FMT=FMT4) GLOBAL_INTER_NODE_REORD(J),
     &        (PART_P(J,K)-1, K=1,MAX_N_NEIGH)
         END IF
      END DO
!
      DO J=1,NHALO
         DO M=0,2
            IF (IFAPAR(2+M,J)>0) THEN
               IFAPAR(5+M,J)=GELEGL1(IFAPAR(5+M,J))
            END IF
         END DO
      END DO
!      IFAPAR(2:4,:)=IFAPAR(2:4,:)-1
      DO J=1,NHALO
         DO M=0,2
            IF (IFAPAR(2+M,J)>0) THEN
               IFAPAR(2+M,J)=IFAPAR(2+M,J)-1
            END IF
         END DO
      END DO
!
      WRITE(NCLM,'(I15)') NHALO
      DO K=1,NHALO

         WRITE (NCLM,'(7(I15,1X))') IFAPAR(:,K)
      END DO
      CLOSE(NCLM)
!
      ALLOCATE (IRAND_P(NPOIN2),STAT=ERR)
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IRAND_P')
!
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'F_P')
      ALLOCATE(IKLES_P(NELEM2*3),STAT=ERR)
      IF(NPLAN.GT.1) THEN
         ALLOCATE(IKLES3D_P(6,NELEM2,NPLAN-1),STAT=ERR)
      ENDIF
      IF (ERR.NE.0) CALL PARTEL_PARA_ALLOER (LU, 'IKLES3D_P')
!
!***************************************************************
!     WRITING GEOMETRY FILES FOR ALL PARTS/PROCESSORS
!
      NAMEOUT(I_LENINP+1:I_LENINP+11) = PARTEL_PARA_EXTENS(NPARTS-1,ID)
!
      OPEN(NOUT,FILE=NAMEOUT,FORM='UNFORMATTED'
     &     ,STATUS='UNKNOWN')
      REWIND(NOUT)
!
!   TITLE, THE NUMBER OF VARIABLES
      WRITE(NOUT) TITLE
      WRITE(NOUT) NVAR,0
!
      DO K=1,NVAR
         WRITE(NOUT) VARIABLE(K)
      END DO
!     WRITE(*,*) 'HERE '
! 10 INTEGERS...
! 1.  IS THE NUMBER OF RECORDINGS IN FILES
! 8.  IS THE NUMBER OF BOUNDARY POINTS (NPTFR_P)
! 9.  IS THE NUMBER OF INTERFACE POINTS (NPTIR_P)
! 10. IS 0 WHEN NO DATE PASSED; 1 IF A DATE/TIME RECORD FOLLOWS
!
!      IB(7) = NPLAN   (ALREADY DONE)
      IB(8) = NPTFR_P
      IB(9) = NPTIR_P
!      WRITE(*,*) 'SD',I,'NPTFR_P(I)',NPTFR_P, 'NPTIR_P(I)',
!     &       NPTIR_P,'NHALO(I)',NHALO,NPOIN_P
      WRITE(NOUT) (IB(K), K=1,10)
      IF (IB(10).EQ.1) THEN
         WRITE(NOUT) DATE(1), DATE(2), DATE(3),
     &               TIME(1), TIME(2), TIME(3)
      ENDIF
      IF(NPLAN.LE.1) THEN
         WRITE(NOUT) NELEM_P, NPOIN_P, NDP, NDUM
      ELSE
         WRITE(NOUT) NELEM_P*(NPLAN-1),
     &               NPOIN_P*NPLAN, NDP, NDUM
      ENDIF
      DO J=1,NELEM_P
         EF=ELELG(J)
         DO K=1,3
            IKLES_P((J-1)*3+K) = KNOGL(IKLES((EF-1)*3+K))
         END DO
      END DO
      IF(NPLAN > 1) THEN
         DO K = 1,NPLAN-1
            DO J = 1,NELEM_P
               IKLES3D_P(1,J,K) = IKLES_P(1+(J-1)*3) + (K-1)*NPOIN_P
               IKLES3D_P(2,J,K) = IKLES_P(2+(J-1)*3) + (K-1)*NPOIN_P
               IKLES3D_P(3,J,K) = IKLES_P(3+(J-1)*3) + (K-1)*NPOIN_P
               IKLES3D_P(4,J,K) = IKLES_P(1+(J-1)*3) +  K   *NPOIN_P
               IKLES3D_P(5,J,K) = IKLES_P(2+(J-1)*3) +  K   *NPOIN_P
               IKLES3D_P(6,J,K) = IKLES_P(3+(J-1)*3) +  K   *NPOIN_P
            ENDDO
         ENDDO
      ENDIF
!
      IF (NPLAN.LE.1) THEN
         WRITE(NOUT)
     &     ((IKLES_P((J-1)*3+K),K=1,3),J=1,NELEM_P)
      ELSE
         WRITE(NOUT)
     &     (((IKLES3D_P(L,J,K),L=1,6),J=1,NELEM_P),K=1,NPLAN-1)
      ENDIF
!
!   INSTEAD OF IRAND, KNOLG IS WRITTEN !!!
!   I.E. THE TABLE PROCESSOR-LOCAL -> PROCESSOR-GLOBAL NODE NUMBERS
!
      IF (NPLAN.EQ.0) THEN
         WRITE(NOUT) (KNOLG(J), J=1,NPOIN_P)
      ELSE
!   BEYOND NPOIN_P(I) : DUMMY VALUES IN KNOLG, NEVER USED
         WRITE(NOUT) (KNOLG(J), J=1,NPOIN_P*NPLAN)
      ENDIF
!
! COMPLETING PLANES OTHER THAN 1 FOR FUNCTIONS F_P
      IF (NPLAN.GT.1) THEN
         DO L=2,NPLAN
            DO J=1,NPOIN_P
               DO K=1,NVAR+2
      F_P(J+(L-1)*NPOIN_P,K) = F(KNOLG(J)+(L-1)*NPOIN2,K)
               END DO
            ENDDO
         ENDDO
      ENDIF
!
!   NODE COORDINATES X AND Y
!
      IF (NPLAN.EQ.0) THEN
         WRITE(NOUT) (F_P(J,1),J=1,NPOIN_P)
         WRITE(NOUT) (F_P(J,2),J=1,NPOIN_P)
      ELSE
         WRITE(NOUT) (F_P(J,1),J=1,NPOIN_P*NPLAN)
         WRITE(NOUT) (F_P(J,2),J=1,NPOIN_P*NPLAN)
      ENDIF
!
!   TIME STAMP (SECONDS)
      WRITE(NOUT) TIMES
!   NOW THE TIME-DEPENDENT VARIABLES
!
      DO K=3,NVAR+2
         IF(NPLAN.EQ.0) THEN
            WRITE(NOUT) (F_P(J,K),J=1,NPOIN_P)
         ELSE
            WRITE(NOUT) (F_P(J,K),J=1,NPOIN_P*NPLAN)
         ENDIF
      END DO
      CLOSE (NOUT)
      CALL MPI_BARRIER(MPI_COMM_WORLD,IER)
!
!======================================================================
!   WRITING EPART AND NPART
!
! //// JAJ: LA FINITA COMMEDIA FOR PARALLEL CHARACTERISTICS, BYE!
!----------------------------------------------------------------------
!
!   NOTE BY J-M HERVOUET : DEALLOCATE CAUSES ERRORS ON HP
!   (POSSIBLE REMAINING BUG ?)
!   NOTE BY JAJ: DEALLOCATE(HP) ,^)
!
!     DEALLOCATE(NPART)
!     DEALLOCATE(EPART)
!     DEALLOCATE(NPOIN_P)
!     DEALLOCATE(NELEM_P)
!     DEALLOCATE(NPTFR_P)
!     DEALLOCATE(NPTIR_P)
!
!     DEALLOCATE(IKLES)
!     IF(NPLAN.GT.1) THEN
!       DEALLOCATE(IKLES3D)
!       DEALLOCATE(IKLES3D_P)
!     ENDIF
!     DEALLOCATE(IKLES_P)
!     DEALLOCATE(IRAND)
!     DEALLOCATE(IRAND_P)
!     DEALLOCATE(F)
!     DEALLOCATE(F_P)
!
!     DEALLOCATE(KNOLG)
!     DEALLOCATE(KNOGL)
!     DEALLOCATE(ELELG)
!     DEALLOCATE(ELEGL)
!
!     DEALLOCATE(LIHBOR)
!     DEALLOCATE(LIUBOR)
!     DEALLOCATE(LIVBOR)
!     DEALLOCATE(HBOR)
!     DEALLOCATE(UBOR)
!     DEALLOCATE(VBOR)
!     DEALLOCATE(LITBOR)
!     DEALLOCATE(AUBOR)
!     DEALLOCATE(TBOR)
!     DEALLOCATE(ATBOR)
!     DEALLOCATE(BTBOR)
!     DEALLOCATE(NBOR)
!     DEALLOCATE(NUMLIQ)
!     DEALLOCATE(NUMSOL)
!     DEALLOCATE(KP1BOR)
!     DEALLOCATE(CHECK)
!
!     DEALLOCATE(NBOR_P)
!     DEALLOCATE(CUT)
!     DEALLOCATE(CUT_P)
!     DEALLOCATE(PART)
!     DEALLOCATE(PART_P)
!     DEALLOCATE(SORT)
!
!----------------------------------------------------------------------
!
 299  IF (TIMECOUNT) THEN
         CALL SYSTEM_CLOCK (COUNT=TEMPS, COUNT_RATE=PARSEC)
         TFIN = TEMPS
!        WRITE(LU,*) 'OVERALL TIMING: ',
!     &    (1.0*(TFIN-TDEB))/(1.0*PARSEC),' SECONDS'
!        WRITE(LU,*) ' '
      ENDIF
      CALL MPI_BARRIER(MPI_COMM_WORLD,IER)
      IF (ID .EQ. 0) THEN
         ENDTIME=MPI_WTIME()
         WRITE(LU,*) 'TEMPS ECRITURE :',ENDTIME-STARTIOTIME
         WRITE(LU,*) 'TEMPS TOTAL :',ENDTIME-STARTTIME
         WRITE(LU,*) '+---- PARTEL: NORMAL TERMINATION ----+'
      END IF
!
      GO TO 999
 300  WRITE(LU,*) 'ERROR BY READING. '
      CALL PARTEL_PARA_PLANTE2(-1)
      CALL MPI_BARRIER(MPI_COMM_WORLD,IER)
 999  STOP
      END PROGRAM PARTEL_PARA


      SUBROUTINE PARTEL_PARA_ALLOER (N, CHFILE)
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: N
      CHARACTER*(*), INTENT(IN) :: CHFILE
      WRITE(N,*) 'ERROR BY ALLOCATION OF ',CHFILE
      CALL PARTEL_PARA_PLANTE2(-1)
      STOP
      END SUBROUTINE PARTEL_PARA_ALLOER

      SUBROUTINE PARTEL_PARA_ALLOER2(N,CHFILE)
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: N
      CHARACTER*(*), INTENT(IN) :: CHFILE
      WRITE(N,*)TRIM(CHFILE)
      CALL PARTEL_PARA_PLANTE2(-1)
      STOP
      END SUBROUTINE PARTEL_PARA_ALLOER2


      SUBROUTINE PARTEL_PARA_PLANTE2 (IVAL)
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
!
      INTEGER, INTENT(IN) :: IVAL
      INTEGER ICODE
!     STANDARD F90 :  STOP [n] WHERE N IS A STRING OF NOT MORE
!     THAN FIVE DIGITS OR IS A CHARACTER CONSTANT.
!     HOWEVER, CODE IS NOT ALWAYS SENT TO STDERR
!     (COMPILER DEPENDENT, NAG DOESN'T FOR INSTANCE)
!     ICODE MIGHT BE USED IN A POSSIBLE SYSTEM DEPENDENT EXIT PROCEDURE
!     EXAMPLE : STOP 1 ; STOP '    1'
      IF(IVAL.LT.0) THEN
        ICODE = 0      ! JUST ASSUMED FOR NON-ERROR STOP
      ELSEIF(IVAL.EQ.0.OR.IVAL.EQ.1) THEN
        ICODE = 2      ! EXIT IVAL 0 OR 1 INDICATING A "CONTROLLED" ERROR
        STOP 2
      ELSE
        ICODE = 1     ! SOMETHING ELSE? BUT AN ERROR!
        STOP 1
      ENDIF
      WRITE(LU,*) 'RETURNING EXIT CODE: ', ICODE
      STOP 0   !WHICH IS USUALLY EQUIVALENT TO CALL EXIT(0)

!     JMH 30/09/2011 WHAT IS THIS (NAG COMPILER DOES NOT KNOW)
!     CALL EXIT(ICODE)
      END SUBROUTINE PARTEL_PARA_PLANTE2
C
C                       *********************************************
                        CHARACTER(LEN=11) FUNCTION PARTEL_PARA_EXTENS
C                       *********************************************
C
     *(N,IPID)
C
C***********************************************************************
C  PARA       VERSION 4.0         08/01/97        J-M HERVOUET (LNH)
C
C***********************************************************************
C
C      FONCTIONS: PARTEL_PARA_EXTENSION DES FICHIERS SUR CHAQUE PROCESSEUR.
C      ==========
C
C-----------------------------------------------------------------------
C                             ARGUMENTS
C .________________.____.______________________________________________.
C |      NOM       |MODE|                   ROLE
C |________________|____|______________________________________________|
C |     N          | -->| NOMBRE DE PROCESSEURS MOINS UN = NCSIZE-1
C |     IPID       | -->| NUMERO DU PROCESSEUR
C |________________|____|______________________________________________|
C MODE : -->(DONNEE NON MODIFIEE), <--(RESULTAT), <-->(DONNEE MODIFIEE)
C
C-----------------------------------------------------------------------
C
C APPELE PAR :
C
C SOUS-PROGRAMMES APPELES : NEANT
C
C**********************************************************************
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
      INTEGER IPID,N
C
C-----------------------------------------------------------------------
C
      IF(N.GT.0) THEN
C
        PARTEL_PARA_EXTENS='00000-00000'
C
        IF(N.LT.10) THEN
          WRITE(PARTEL_PARA_EXTENS(05:05),'(I1)') N
        ELSEIF(N.LT.100) THEN
          WRITE(PARTEL_PARA_EXTENS(04:05),'(I2)') N
        ELSEIF(N.LT.1000) THEN
          WRITE(PARTEL_PARA_EXTENS(03:05),'(I3)') N
        ELSEIF(N.LT.10000) THEN
          WRITE(PARTEL_PARA_EXTENS(02:05),'(I4)') N
        ELSE
          WRITE(PARTEL_PARA_EXTENS(01:05),'(I5)') N
        ENDIF
C
        IF(IPID.LT.10) THEN
          WRITE(PARTEL_PARA_EXTENS(11:11),'(I1)') IPID
        ELSEIF(IPID.LT.100) THEN
          WRITE(PARTEL_PARA_EXTENS(10:11),'(I2)') IPID
        ELSEIF(IPID.LT.1000) THEN
          WRITE(PARTEL_PARA_EXTENS(09:11),'(I3)') IPID
        ELSEIF(IPID.LT.10000) THEN
          WRITE(PARTEL_PARA_EXTENS(08:11),'(I4)') IPID
        ELSE
          WRITE(PARTEL_PARA_EXTENS(07:11),'(I5)') IPID
        ENDIF
C
      ELSE
C
        PARTEL_PARA_EXTENS='       '
C
      ENDIF
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C                       ************************
                        SUBROUTINE PARTEL_FRONT2
C                       ************************
C
     *(NFRLIQ,NFRSOL,DEBLIQ,FINLIQ,DEBSOL,FINSOL,LIHBOR,LIUBOR,
     * X,Y,NBOR,KP1BOR,DEJAVU,NPOIN,NPTFR,KLOG,LISTIN,NUMLIQ,NUMSOL,
     * NPTFRMAX)
C
C***********************************************************************
C BIEF VERSION 5.5           04/05/04    J-M HERVOUET  01 30 87 80 18
C***********************************************************************
C
C  FONCTION  : REPERAGE, NUMEROTATION DES FRONTIERES LIQUIDES ET SOLIDES
C
C-----------------------------------------------------------------------
C                             ARGUMENTS
C .________________.____.______________________________________________
C |      NOM       |MODE|                   ROLE
C |________________|____|______________________________________________
C |   NFRLIQ       |<-- | NOMBRE DE FRONTIERES LIQUIDES
C |   NFRSOL       |<-- | NOMBRE DE FRONTIERES SOLIDES
C |   DEBLIQ       |<-- | DEBUTS DES FRONTIERES LIQUIDES
C |   FINLIQ       |<-- | FINS DES FRONTIERES LIQUIDES
C |   DEBSOL       |<-- | DEBUTS DES FRONTIERES SOLIDES
C |   FINSOL       |<-- | FINS DES FRONTIERES SOLIDES
C |   LIHBOR       | -->| CONDITIONS AUX LIMITES SUR H
C |   X , Y        | -->| COORDONNEES DU MAILLAGE.
C |   NBOR         | -->| NUMEROS GLOBAUX DES POINTS DE BORD
C |   KP1BOR       | -->| NUMEROS DES EXTREMITES DES SEGMENTS DE BORD
C |                |    | DANS LA NUMEROTATION DES POINTS DE BORD
C |   DEJAVU       | -- | TABLEAU DE TRAVAIL
C |   NPOIN        | -->| NOMBRE DE POINTS DU MAILLAGE
C |   NPTFR        | -->| NOMBRE DE POINTS FRONTIERE
C |   KLOG         | -->| LIHBOR(K)=KLOG : FRONTIERE SOLIDE
C |   LISTIN       | -->| IMPRESSIONS SUR LISTING (OU NON)
C |________________|____|______________________________________________
C MODE : -->(DONNEE NON MODIFIEE), <--(RESULTAT), <-->(DONNEE MODIFIEE)
C-----------------------------------------------------------------------
C
C  PRECAUTIONS D'EMPLOI : LES FRONTIERES SOLIDES SONT REPEREES PAR LE
C                         FAIT QUE LIHBOR(K) = KLOG POUR UN POINT DE
C                         BORD DE NUMERO K.
C                         UN SEGMENT COMPRIS ENTRE UN POINT LIQUIDE ET
C                         UN POINT SOLIDE EST SOLIDE.
C
C***********************************************************************
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER, INTENT(IN) :: NPOIN,NPTFR,KLOG,NPTFRMAX
      INTEGER, INTENT(OUT) :: NFRLIQ,NFRSOL
C                                    *=MAXFRO (300 DANS TELEMAC-2D)
      INTEGER, INTENT(OUT) :: DEBLIQ(*),FINLIQ(*),DEBSOL(*),FINSOL(*)
CCCCCCMOULINEC BEGIN
      INTEGER , INTENT(IN) :: LIHBOR(NPTFRMAX),LIUBOR(NPTFRMAX)
C      INTEGER , INTENT(IN) :: LIHBOR(NPTFR),LIUBOR(NPTFR)
CCCCCCMOULINEC END
      REAL, INTENT(IN) :: X(NPOIN) , Y(NPOIN)
CCCCCCMOULINEC BEGIN
      INTEGER, INTENT(IN) :: NBOR(2*NPTFRMAX),KP1BOR(NPTFR)
C      INTEGER, INTENT(IN) :: NBOR(NPTFR),KP1BOR(NPTFR)
CCCCCCMOULINEC END
      INTEGER, INTENT(OUT) :: DEJAVU(NPTFR)
      LOGICAL, INTENT(IN) :: LISTIN
CCCCCCMOULINEC BEGIN
      INTEGER, INTENT(OUT) :: NUMLIQ(NPTFRMAX)
      INTEGER, INTENT(OUT) :: NUMSOL(NPTFRMAX)
C      INTEGER, INTENT(OUT) :: NUMLIQ(NPTFR)
C      INTEGER, INTENT(OUT) :: NUMSOL(NPTFR)
CCCCCCMOULINEC END
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER K,KPREV,IDEP,SOL1,LIQ1,L1,L2,L3,NILE
C
      LOGICAL SOLF,LIQF,SOLD,LIQD
C
      REAL MINNS,MAXNS,EPS,YMIN,NS
C
      INTRINSIC ABS
C
C-----------------------------------------------------------------------
C
C  INITIALISATIONS
C
C  DEJAVU : MARQUE D'UN 1 LES POINTS DEJA TRAITES
C  NILE   : NOMBRE D'ILES
C
      DO 10 K=1,NPTFR
        DEJAVU(K) = 0
        NUMLIQ(K) = 0
        NUMSOL(K) = 0
10    CONTINUE
C
      NILE = 0
      IDEP = 1
      NFRLIQ = 0
      NFRSOL = 0
C
C-----------------------------------------------------------------------
C
C  ON REVIENDRA A L'ETIQUETTE 20 S'IL Y A AU MOINS UNE ILE
C
20    CONTINUE
C
C  RECHERCHE DU POINT LE PLUS SUD-OUEST (IL PEUT Y EN AVOIR PLUSIEURS)
C
      MINNS = X(NBOR(IDEP)) + Y(NBOR(IDEP))
      MAXNS = MINNS
      YMIN  = Y(NBOR(IDEP))
C
      DO 30 K = 1 , NPTFR
      IF(DEJAVU(K).EQ.0) THEN
        NS = X(NBOR(K)) + Y(NBOR(K))
        IF(NS.LT.MINNS) THEN
         IDEP = K
         MINNS = NS
         YMIN = Y(NBOR(K))
        ENDIF
        IF(NS.GT.MAXNS) MAXNS = NS
      ENDIF
30    CONTINUE
C
      EPS = (MAXNS-MINNS) * 1.D-4
C
C  CHOIX DU POINT LE PLUS SUD PARMI LES CANDIDATS SUD-OUEST
C
      DO 40 K = 1 , NPTFR
      IF(DEJAVU(K).EQ.0) THEN
        NS = X(NBOR(K)) + Y(NBOR(K))
        IF(ABS(MINNS-NS).LT.EPS) THEN
          IF(Y(NBOR(K)).LT.YMIN) THEN
           IDEP = K
           YMIN = Y(NBOR(K))
          ENDIF
        ENDIF
      ENDIF
40    CONTINUE
C
C-----------------------------------------------------------------------
C
C  NUMEROTATION ET REPERAGE DES FRONTIERES DU CONTOUR COMMENCANT
C  AU POINT IDEP.
C
C  SOLD = .TRUE. : LA FRONTIERE AU DEPART DE IDEP EST SOLIDE
C  LIQD = .TRUE. : LA FRONTIERE AU DEPART DE IDEP EST LIQUIDE
C  SOLF = .TRUE. : LA FRONTIERE AU RETOUR A IDEP EST SOLIDE
C  LIQF = .TRUE. : LA FRONTIERE AU RETOUR A IDEP EST LIQUIDE
C  LIQ1 : NUMERO DE LA PREMIERE FRONTIERE LIQUIDE DU CONTOUR
C  SOL1 : NUMERO DE LA PREMIERE FRONTIERE SOLIDE DU CONTOUR
C
      K = IDEP
C
      SOL1 = 0
      LIQ1 = 0
      LIQF = .FALSE.
      SOLF = .FALSE.
C
C NATURE DU PREMIER SEGMENT
C
C     LOI DE DOMINANCE DU SOLIDE SUR LE LIQUIDE
      IF(LIHBOR(K).EQ.KLOG.OR.LIHBOR(KP1BOR(K)).EQ.KLOG) THEN
C       LE PREMIER SEGMENT EST SOLIDE
        NFRSOL = NFRSOL + 1
        SOL1 = NFRSOL
        SOLD = .TRUE.
        LIQD = .FALSE.
      ELSE
C       LE PREMIER SEGMENT EST LIQUIDE
        NFRLIQ = NFRLIQ + 1
        LIQ1 = NFRLIQ
        LIQD = .TRUE.
        SOLD = .FALSE.
      ENDIF
C
      DEJAVU(K) = 1
      KPREV = K
      K = KP1BOR(K)
C
50    CONTINUE
C
C RECHERCHE DES POINTS DE TRANSITION A PARTIR DU POINT SUIVANT IDEB
C
C ON CHERCHE AUSSI LES CAS DE POINTS ISOLES POUR DETECTER LES ERREURS
C DANS LES DONNEES.
C
      L1 = LIHBOR(KPREV)
      L2 = LIHBOR(K)
      L3 = LIHBOR(KP1BOR(K))
C
      IF(L1.EQ.KLOG.AND.L2.NE.KLOG.AND.L3.NE.KLOG) THEN
C     TRANSITION SOLIDE-LIQUIDE AU POINT K
        NFRLIQ = NFRLIQ + 1
        FINSOL(NFRSOL) = K
        DEBLIQ(NFRLIQ) = K
        LIQF = .TRUE.
        SOLF = .FALSE.
      ELSEIF(L1.NE.KLOG.AND.L2.NE.KLOG.AND.L3.EQ.KLOG) THEN
C     TRANSITION LIQUIDE-SOLIDE AU POINT K
        NFRSOL = NFRSOL + 1
        FINLIQ(NFRLIQ) = K
        DEBSOL(NFRSOL) = K
        LIQF = .FALSE.
        SOLF = .TRUE.
      ELSEIF(L1.NE.KLOG.AND.L2.NE.KLOG.AND.L3.NE.KLOG) THEN
C     RECHERCHE DES TRANSITIONS LIQUIDE-LIQUIDE AU POINT K
        IF(L2.NE.L3.OR.LIUBOR(K).NE.LIUBOR(KP1BOR(K))) THEN
          FINLIQ(NFRLIQ) = K
          NFRLIQ = NFRLIQ + 1
          DEBLIQ(NFRLIQ) = KP1BOR(K)
        ENDIF
      ELSEIF(L1.EQ.KLOG.AND.L2.NE.KLOG.AND.L3.EQ.KLOG) THEN
C     ERREUR DANS LES DONNEES
        IF(LNG.EQ.1) WRITE(LU,102) K
        IF(LNG.EQ.2) WRITE(LU,103) K
        CALL PARTEL_PARA_PLANTE2(-1)
        STOP
      ELSEIF(L1.NE.KLOG.AND.L2.EQ.KLOG.AND.L3.NE.KLOG) THEN
C     ERREUR DANS LES DONNEES
        IF(LNG.EQ.1) WRITE(LU,104) K
        IF(LNG.EQ.2) WRITE(LU,105) K
        CALL PARTEL_PARA_PLANTE2(-1)
        STOP
      ENDIF
C
      DEJAVU(K) = 1
      KPREV = K
      K = KP1BOR(K)
      IF(K.NE.IDEP) GO TO 50
C
C  CAS D'UN CHANGEMENT DE FRONTIERE AU POINT DE DEPART IDEP
C
      IF(SOLF) THEN
C       LA DERNIERE FRONTIERE ETAIT SOLIDE
        IF(SOLD) THEN
C         LA PREMIERE FRONTIERE ETAIT SOLIDE
          DEBSOL(SOL1) = DEBSOL(NFRSOL)
          NFRSOL = NFRSOL - 1
        ELSEIF(LIQD) THEN
C         LA PREMIERE FRONTIERE ETAIT LIQUIDE
          DEBLIQ(LIQ1) = IDEP
          FINSOL(NFRSOL) = IDEP
        ENDIF
C
      ELSEIF(LIQF) THEN
C       LA DERNIERE FRONTIERE DU CONTOUR ETAIT LIQUIDE
        IF(LIQD) THEN
C         LA PREMIERE FRONTIERE DU CONTOUR ETAIT LIQUIDE
          DEBLIQ(LIQ1) = DEBLIQ(NFRLIQ)
          NFRLIQ = NFRLIQ - 1
        ELSEIF(SOLD) THEN
C         LA PREMIERE FRONTIERE DU CONTOUR ETAIT SOLIDE
          DEBSOL(SOL1) = IDEP
          FINLIQ(NFRLIQ) = IDEP
        ENDIF
C
      ELSE
C     CAS OU TOUT LE CONTOUR EST DU MEME TYPE
        IF(SOL1.NE.0) THEN
          DEBSOL(SOL1) = IDEP
          FINSOL(SOL1) = IDEP
        ELSEIF(LIQ1.NE.0) THEN
          DEBLIQ(LIQ1) = IDEP
          FINLIQ(LIQ1) = IDEP
        ELSE
          IF(LISTIN.AND.LNG.EQ.1) THEN
           WRITE(LU,'(1X,A)') 'CAS IMPOSSIBLE DANS FRONT2'
          ENDIF
          IF(LISTIN.AND.LNG.EQ.2) THEN
           WRITE(LU,'(1X,A)') 'IMPOSSIBLE CASE IN FRONT2'
          ENDIF
          CALL PARTEL_PARA_PLANTE2(-1)
          STOP
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C  ON REGARDE S'IL RESTE DES CONTOURS :
C
      DO 60 K = 1 , NPTFR
        IF(DEJAVU(K).EQ.0) THEN
          IDEP = K
          NILE = NILE + 1
          GO TO 20
        ENDIF
60    CONTINUE
C
C-----------------------------------------------------------------------
C
      DO 79 K=1,NPTFR
        NUMLIQ(K)=0
79    CONTINUE
C
C  IMPRESSION DES RESULTATS ET CALCUL DE NUMLIQ
C
      IF(NILE.NE.0.AND.LISTIN.AND.LNG.EQ.1) WRITE(LU,69) NILE
      IF(NILE.NE.0.AND.LISTIN.AND.LNG.EQ.2) WRITE(LU,169) NILE
C
      IF(NFRLIQ.NE.0) THEN
        IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,70) NFRLIQ
        IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,170) NFRLIQ

        DO 80 K = 1, NFRLIQ
C
C  MARQUAGE DES NUMEROS DES FRONTIERES LIQUIDES
C
          L1=DEBLIQ(K)
          NUMLIQ(L1)=K
707       L1=KP1BOR(L1)
          NUMLIQ(L1)=K
          IF(L1.NE.FINLIQ(K)) GO TO 707
C
C  FIN DU MARQUAGE
C
          IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,90)
     *                            K,DEBLIQ(K),NBOR(DEBLIQ(K)),
     *                            X(NBOR(DEBLIQ(K))),Y(NBOR(DEBLIQ(K))),
     *                            FINLIQ(K),NBOR(FINLIQ(K)),
     *                            X(NBOR(FINLIQ(K))),Y(NBOR(FINLIQ(K)))
          IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,190)
     *                            K,DEBLIQ(K),NBOR(DEBLIQ(K)),
     *                            X(NBOR(DEBLIQ(K))),Y(NBOR(DEBLIQ(K))),
     *                            FINLIQ(K),NBOR(FINLIQ(K)),
     *                            X(NBOR(FINLIQ(K))),Y(NBOR(FINLIQ(K)))
80      CONTINUE
      ENDIF
C
      IF(NFRSOL.NE.0) THEN
        IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,100) NFRSOL
        IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,101) NFRSOL

        DO 110 K = 1, NFRSOL
!
!  MARKING SOLID BOUNDARIES (WHY NOT?)
!  THEY GET NEXT BOUNDARY NUMBERS
!
          L1=DEBSOL(K)
          NUMSOL(L1)=K+NFRLIQ
708       L1=KP1BOR(L1)
          NUMSOL(L1)=K+NFRLIQ
          IF(L1.NE.FINSOL(K)) GO TO 708
!
!  END OD FMARKING
!
          IF(LISTIN.AND.LNG.EQ.1) WRITE(LU,90)
     *                            K,DEBSOL(K),NBOR(DEBSOL(K)),
     *                            X(NBOR(DEBSOL(K))),Y(NBOR(DEBSOL(K))),
     *                            FINSOL(K),NBOR(FINSOL(K)),
     *                            X(NBOR(FINSOL(K))),Y(NBOR(FINSOL(K)))
          IF(LISTIN.AND.LNG.EQ.2) WRITE(LU,190)
     *                            K,DEBSOL(K),NBOR(DEBSOL(K)),
     *                            X(NBOR(DEBSOL(K))),Y(NBOR(DEBSOL(K))),
     *                            FINSOL(K),NBOR(FINSOL(K)),
     *                            X(NBOR(FINSOL(K))),Y(NBOR(FINSOL(K)))
110     CONTINUE
      ENDIF
C
C-----------------------------------------------------------------------
C
C  FORMATS
C
69    FORMAT(/,1X,'IL Y A ',1I15,' ILE(S) DANS LE DOMAINE')
169   FORMAT(/,1X,'THERE IS ',1I15,' ISLAND(S) IN THE DOMAIN')
70    FORMAT(/,1X,'IL Y A ',1I15,' FRONTIERE(S) LIQUIDE(S) :')
170   FORMAT(/,1X,'THERE IS ',1I15,' LIQUID BOUNDARIES:')
100   FORMAT(/,1X,'IL Y A ',1I15,' FRONTIERE(S) SOLIDE(S) :')
101   FORMAT(/,1X,'THERE IS ',1I15,' SOLID BOUNDARIES:')
102   FORMAT(/,1X,'FRONT2 : ERREUR AU POINT DE BORD ',1I15,
     *       /,1X,'         POINT LIQUIDE ENTRE DEUX POINTS SOLIDES')
103   FORMAT(/,1X,'FRONT2 : ERROR AT BOUNDARY POINT ',1I15,
     *       /,1X,'         LIQUID POINT BETWEEN TWO SOLID POINTS')
104   FORMAT(/,1X,'FRONT2 : ERREUR AU POINT DE BORD ',1I15,
     *       /,1X,'         POINT SOLIDE ENTRE DEUX POINTS LIQUIDES')
105   FORMAT(/,1X,'FRONT2 : ERROR AT BOUNDARY POINT ',1I15,
     *       /,1X,'         SOLID POINT BETWEEN TWO LIQUID POINTS')
90    FORMAT(/,1X,'FRONTIERE ',1I15,' : ',/,1X,
     *            ' DEBUT AU POINT DE BORD ',1I15,
     *            ' , DE NUMERO GLOBAL ',1I15,/,1X,
     *            ' ET DE COORDONNEES : ',G16.7,3X,G16.7,
     *       /,1X,' FIN AU POINT DE BORD ',1I15,
     *            ' , DE NUMERO GLOBAL ',1I15,/,1X,
     *            ' ET DE COORDONNEES : ',G16.7,3X,G16.7)
190   FORMAT(/,1X,'BOUNDARY ',1I15,' : ',/,1X,
     *            ' BEGINS AT BOUNDARY POINT: ',1I15,
     *            ' , WITH GLOBAL NUMBER: ',1I15,/,1X,
     *            ' AND COORDINATES: ',G16.7,3X,G16.7,
     *       /,1X,' ENDS AT BOUNDARY POINT: ',1I15,
     *            ' , WITH GLOBAL NUMBER: ',1I15,/,1X,
     *            ' AND COORDINATES: ',G16.7,3X,G16.7)
C
C-----------------------------------------------------------------------
C
      IF(NILE.GT.300.OR.NFRSOL.GT.300.OR.NFRLIQ.GT.300) THEN
        IF(LNG.EQ.1) THEN
          WRITE(LU,*) 'FRONT2 : DEPASSEMENT DE TABLEAUX'
          WRITE(LU,*) '         AUGMENTER MAXFRO DANS LE CODE APPELANT'
          WRITE(LU,*) '         A LA VALEUR ',MAX(NILE,NFRSOL,NFRLIQ)
        ENDIF
        IF(LNG.EQ.2) THEN
          WRITE(LU,*) 'FRONT2: SIZE OF ARRAYS EXCEEDED'
          WRITE(LU,*) '        INCREASE MAXFRO IN THE CALLING PROGRAM'
          WRITE(LU,*) '        UP TO THE VALUE ',MAX(NILE,NFRSOL,NFRLIQ)
        ENDIF
        CALL PARTEL_PARA_PLANTE2(-1)
        STOP
      ENDIF
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C                       ************************
                        SUBROUTINE PARTEL_VOISIN
C                       ************************
C
     *(IFABOR,NELEM,NELMAX,IELM,IKLE,SIZIKL,NPOIN,IADR,NVOIS)
C
C***********************************************************************
C BIEF VERSION 5.9         16/06/2008    J-M HERVOUET (LNHE) 30 87 80 18
C
C***********************************************************************
C
C    FONCTION : CONSTRUCTION DU TABLEAU IFABOR, OU IFABOR(IELEM,IFACE)
C               EST LE NUMERO GLOBAL DU VOISIN DE LA FACE IFACE DE
C               L'ELEMENT IELEM SI CE VOISIN EXISTE ET 0 SI LA FACE EST
C               SUR LA FRONTIERE DU DOMAINE.
C
C-----------------------------------------------------------------------
C                             ARGUMENTS
C .________________.____.______________________________________________.
C |      NOM       |MODE|                   ROLE                       |
C |________________|____|______________________________________________|
C |    IFABOR      |<-- | TABLEAU DES VOISINS DES FACES.
C |    NELEM       | -->| NOMBRE D'ELEMENTS DANS LE MAILLAGE.
C |    NELMAX      | -->| NOMBRE MAXIMUM D'ELEMENTS DANS LE MAILLAGE.
C |                |    | (CAS DES MAILLAGES ADAPTATIFS)
C |    IELM        | -->| 11: TRIANGLES
C |                |    | 21: QUADRILATERES
C |    IKLE        | -->| NUMEROS GLOBAUX DES POINTS DE CHAQUE ELEMENT
C |    NPOIN       | -->| NOMBRE TOTAL DE POINTS DU DOMAINE
C |________________|____|_______________________________________________
C  MODE: -->(DONNEE NON MODIFIEE),<--(RESULTAT),<-->(DONNEE MODIFIEE)
C-----------------------------------------------------------------------
C
C PROGRAMME APPELANT DANS TELEMAC 2D : PREDAT
C
C***********************************************************************
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
      INTEGER IR1,IR2,IR3,IR4,SIZIKL
C
      INTEGER NELEM,NELMAX,IELM,IDIMAT,NPOIN,I,J,ERR,NDP
      INTEGER NFACE,KEL,I1,I2,IMAX,IFACE,IELEM,M1,M2,IV,IELEM2,IFACE2
      INTEGER IFABOR(NELMAX,*),IKLE(SIZIKL,*),NVOIS(NPOIN),IADR(NPOIN)
C
      INTEGER SOMFAC(2,4,2)
      DATA SOMFAC / 1,2 , 2,3 , 3,1 , 0,0   ,  1,2 , 2,3 , 3,4 , 4,1 /
C
C  TABLEAUX DE TRAVAIL ALLOUES DYNAMIQUEMENT
C
      INTEGER, DIMENSION(:), ALLOCATABLE :: MAT1,MAT2,MAT3
C
C-----------------------------------------------------------------------
C
      IF(IELM.EQ.21) THEN
C       QUADRILATERES
        NFACE = 4
        NDP = 4
        KEL = 2
      ELSEIF(IELM.EQ.11.OR.IELM.EQ.41) THEN
C       TRIANGLES
        NFACE = 3
        NDP = 3
        KEL = 1
      ELSE
        IF(LNG.EQ.1) WRITE(LU,98) IELM
        IF(LNG.EQ.2) WRITE(LU,99) IELM
98      FORMAT(1X,'VOISIN: IELM=',1I15,' TYPE D''ELEMENT NON PREVU')
99      FORMAT(1X,'VOISIN: IELM=',1I15,' TYPE OF ELEMENT NOT AVAILABLE')
        CALL PARTEL_PARA_PLANTE2(-1)
        STOP
      ENDIF
C
C-----------------------------------------------------------------------
C
C     IDIMAT EST UNE MAJORATION DE LA SOMME DES NOMBRES DE VOISINS DE
C     TOUS LES POINTS.
C
      IDIMAT = 2*NDP*NELEM
C
      ALLOCATE(MAT1(IDIMAT),STAT=ERR)
      ALLOCATE(MAT2(IDIMAT),STAT=ERR)
      ALLOCATE(MAT3(IDIMAT),STAT=ERR)
C
      IF(ERR.NE.0) THEN
        IF(LNG.EQ.1) WRITE(LU,1000) ERR
        IF(LNG.EQ.2) WRITE(LU,2000) ERR
1000    FORMAT(1X,'VOISIN : ERREUR A L''ALLOCATION DE MEMOIRE : ',/,1X,
     *            'CODE D''ERREUR : ',1I15)
2000    FORMAT(1X,'VOISIN: ERROR DURING ALLOCATION OF MEMORY: ',/,1X,
     *            'ERROR CODE: ',1I15)
      ENDIF
C
C-----------------------------------------------------------------------
C
C  CALCUL DU TABLEAU NVOIS POUR CHAQUE POINT
C  ATTENTION : NVOIS N'EST PAS LE NOMBRE DE VOISINS MAIS PERMET DE
C              RESERVER ASSEZ DE PLACE DANS LES TABLEAUX MAT1,2,3.
C
      DO 10 I=1,NPOIN
        NVOIS(I) = 0
10    CONTINUE
C
      DO 20 IFACE = 1,NFACE
        DO 30 IELEM=1,NELEM
          I1 = IKLE( IELEM , SOMFAC(1,IFACE,KEL) )
          I2 = IKLE( IELEM , SOMFAC(2,IFACE,KEL) )
          NVOIS(I1) = NVOIS(I1) + 1
          NVOIS(I2) = NVOIS(I2) + 1
30      CONTINUE
20    CONTINUE
C
C-----------------------------------------------------------------------
C
C  CALCUL DES ADRESSES DE CHAQUE POINT DANS UNE STRUCTURE DE TYPE
C  MATRICE COMPACTE
C
      IADR(1) = 1
      DO 50 I= 2,NPOIN
        IADR(I) = IADR(I-1) + NVOIS(I-1)
50    CONTINUE
C
      IMAX = IADR(NPOIN) + NVOIS(NPOIN) - 1
      IF(IMAX.GT.IDIMAT) THEN
        IF(LNG.EQ.1) WRITE(LU,51) IDIMAT,IMAX
        IF(LNG.EQ.2) WRITE(LU,52) IDIMAT,IMAX
51      FORMAT(1X,'VOISIN: TAILLE DE MAT1,2,3 (',1I15,') INSUFFISANTE',/,
     *         1X,'IL FAUT AU MOINS : ',1I15)
52      FORMAT(1X,'VOISIN: SIZE OF MAT1,2,3 (',1I15,') TOO SHORT',/,
     *         1X,'MINIMUM SIZE: ',1I15)
        CALL PARTEL_PARA_PLANTE2(-1)
        STOP
      ENDIF
C
C-----------------------------------------------------------------------
C
C  INITIALISATION A ZERO DE LA MATRICE COMPACTE
C
      DO 53 I=1,IMAX
        MAT1(I) = 0
53    CONTINUE
C
C-----------------------------------------------------------------------
C
C  BOUCLE SUR LES FACES DE CHAQUE ELEMENT :
C
      DO 60 IFACE = 1 , NFACE
      DO 70 IELEM = 1 , NELEM
C
      IFABOR(IELEM,IFACE) = -1
C
C        NUMEROS GLOBAUX DES POINTS DE LA FACE :
C
         I1 = IKLE( IELEM , SOMFAC(1,IFACE,KEL) )
         I2 = IKLE( IELEM , SOMFAC(2,IFACE,KEL) )
C
C        NUMEROS GLOBAUX ORDONNES :
C
         M1 = MIN0(I1,I2)
         M2 = MAX0(I1,I2)
C
         DO 80 IV = 1,NVOIS(M1)
C
           IF(MAT1(IADR(M1)+IV-1).EQ.0) THEN
              MAT1(IADR(M1)+IV-1)=M2
              MAT2(IADR(M1)+IV-1)=IELEM
              MAT3(IADR(M1)+IV-1)=IFACE
              GO TO 81
           ELSEIF(MAT1(IADR(M1)+IV-1).EQ.M2) THEN
              IELEM2 = MAT2(IADR(M1)+IV-1)
              IFACE2 = MAT3(IADR(M1)+IV-1)
              IFABOR(IELEM,IFACE) = IELEM2
              IFABOR(IELEM2,IFACE2) = IELEM
              GO TO 81
           ENDIF
C
80       CONTINUE
C
         IF(LNG.EQ.1) WRITE(LU,82)
         IF(LNG.EQ.2) WRITE(LU,83)
82       FORMAT(1X,'VOISIN : ERREUR DANS LE MAILLAGE       ',/,1X,
     *             '         PEUT-ETRE DES POINTS CONFONDUS')
83       FORMAT(1X,'VOISIN : ERROR IN THE MESH             ',/,1X,
     *             '         MAYBE SUPERIMPOSED POINTS     ')
         CALL PARTEL_PARA_PLANTE2(-1)
         STOP
C
81       CONTINUE
C
70    CONTINUE
60    CONTINUE
C
C-----------------------------------------------------------------------
C
      DEALLOCATE(MAT1)
      DEALLOCATE(MAT2)
      DEALLOCATE(MAT3)
C
C-----------------------------------------------------------------------
C
      RETURN
      END
C                       ***********************
                        SUBROUTINE PARTEL_ELEBD
C                       ***********************
C
C
C      TAKEN FROM BIEF AND ADAPTED : USE BIEF REMOVED
C                                    CALL PLANTE REMOVED
C                                    ALL ACTIONS UNDER IF(NCSIZE.GT.1) REMOVED
C
C
     *(NELBOR,NULONE,KP1BOR,IFABOR,NBOR,IKLE,SIZIKL,
     * IKLBOR,NELEM,NELMAX,NPTFRMAX,
     * NPOIN,NPTFR,IELM,LIHBOR,KLOG,IFANUM,OPTASS,ISEG,T1,T2,T3)
C
C***********************************************************************
C BIEF VERSION 5.3           23/08/99    J-M HERVOUET (LNH) 30 87 80 18
C COPYRIGHT 1999
C***********************************************************************
C
C    PRISMES DECOUPES EN TETRAEDRES
C
C    FONCTION : 1) CONSTRUCTION DES TABLEAUX NELBOR ET NULONE
C               2) CONSTRUCTION DU TABLEAU KP1BOR
C               3) DISTINCTION DANS LE TABLEAU IFABOR ENTRE
C                  LES FACES DE BORD SOLIDES ET LES FACES LIQUIDES
C               4) COMPLEMENT DE NBOR.
C
C-----------------------------------------------------------------------
C                             ARGUMENTS
C .________________.____.______________________________________________.
C |      NOM       |MODE|                   ROLE                       |
C |________________|____|______________________________________________|
C |    NELBOR      |<-- | NUMERO DE L'ELEMENT ADJACENT AU KIEME SEGMENT|
C |    NULONE      |<-- | NUMERO LOCAL D'UN POINT DE BORD DANS         |
C |                |    | L'ELEMENT ADJACENT DONNE PAR NELBOR          |
C |    KP1BOR      |<-- | NUMERO DU POINT SUIVANT LE POINT DE BORD K.  |
C |    IFABOR      | -->| TABLEAU DES VOISINS DES FACES.
C |    NBOR        | -->| NUMERO GLOBAL DU POINT DE BORD K.
C |    IKLE        | -->| NUMEROS GLOBAUX DES POINTS DE CHAQUE ELEMENT.
C |    NELEM       | -->| NOMBRE TOTAL D'ELEMENTS DANS LE MAILLAGE.
C |    T1,2,3      | -->| TABLEAUX DE TRAVAIL ENTIERS.
C |    NPOIN       | -->| NOMBRE TOTAL DE POINTS DU DOMAINE.
C |    NPTFR       | -->| NOMBRE DE POINTS FRONTIERES.
C |    IELM        | -->| TYPE D'ELEMENT.
C |                |    | 11 : TRIANGLES.
C |                |    | 21 : QUADRILATERES.
C |    LIHBOR      | -->| TYPES DE CONDITIONS AUX LIMITES SUR H
C |    KLOG        | -->| CONVENTION POUR LA CONDITION LIMITE DE PAROI
C |    MXPTVS      | -->| NOMBRE MAXIMUM DE VOISINS D'UN POINT
C |    MXELVS      | -->| NOMBRE MAXIMUM D'ELEMENTS AUTOUR D'UN POINT
C |________________|____|______________________________________________|
C  MODE: -->(DONNEE NON MODIFIEE),<--(RESULTAT),<-->(DONNEE MODIFIEE)
C
C-----------------------------------------------------------------------
C
C APPELE PAR :
C
C SOUS-PROGRAMME APPELE : NEANT
C
C***********************************************************************
C
      IMPLICIT NONE
      INTEGER LNG,LU
      COMMON/INFO/LNG,LU
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER, INTENT(IN)    :: KLOG,NELMAX,NELEM,SIZIKL
      INTEGER, INTENT(IN)    :: NPOIN,NPTFR,IELM,OPTASS,NPTFRMAX
      INTEGER, INTENT(OUT)   :: NELBOR(NPTFR),NULONE(NPTFR,2)
      INTEGER, INTENT(OUT)   :: KP1BOR(NPTFR,2)
      INTEGER, INTENT(INOUT) :: NBOR(2*NPTFRMAX)
      INTEGER, INTENT(INOUT) :: IFABOR(NELMAX,*)
      INTEGER, INTENT(IN)    :: IKLE(SIZIKL,*)
      INTEGER, INTENT(IN)    :: LIHBOR(NPTFRMAX)
      INTEGER, INTENT(OUT)   :: IKLBOR(NPTFR,2)
      INTEGER, INTENT(INOUT) :: IFANUM(NELMAX,*)
      INTEGER, INTENT(IN)    :: ISEG(NPTFR)
      INTEGER, INTENT(OUT)   :: T1(NPOIN),T2(NPOIN),T3(NPOIN)
C
C+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
C
      INTEGER IELEM,NFACE,NPT,KEL,IPOIN
      INTEGER K,IFACE,I1,I2,N1,N2,IPT,IEL,I,K1,K2
C
      INTEGER SOMFAC(2,4,2)
C
      DATA SOMFAC / 1,2 , 2,3 , 3,1 , 0,0   ,  1,2 , 2,3 , 3,4 , 4,1 /
C
C-----------------------------------------------------------------------
C
      IF(IELM.EQ.11.OR.IELM.EQ.41.OR.IELM.EQ.51) THEN
C       TRIANGLES
        NFACE = 3
        NPT = 3
        KEL = 1
      ELSE
        IF(LNG.EQ.1) WRITE(LU,900) IELM
        IF(LNG.EQ.2) WRITE(LU,901) IELM
900     FORMAT(1X,'ELEBD : IELM=',1I15,' TYPE D''ELEMENT INCONNU')
901     FORMAT(1X,'ELEBD: IELM=',1I15,' UNKNOWN TYPE OF ELEMENT')
        CALL PARTEL_PARA_PLANTE2(-1)
        STOP
      ENDIF
C
C  INITIALISATION DE T1,2,3 A ZERO
C
      DO IPOIN=1,NPOIN
        T1(IPOIN) = 0
        T2(IPOIN) = 0
        T3(IPOIN) = 0
      ENDDO
C
C  ON STOCKE K DANS TRAV(*,3) A L'ADRESSE NBOR(K)
C  CE QUI PERMET DE PASSER DE NUMERO GLOBAL A NUMERO DE BORD
C
      DO K = 1, NPTFR
         T3(NBOR(K)) = K
      ENDDO
C
C  BOUCLE SUR TOUTES LES FACES DE TOUS LES ELEMENTS :
C
      DO 20 IFACE = 1 , NFACE
      DO 10 IELEM = 1 , NELEM
C
      IF(IFABOR(IELEM,IFACE).EQ.-1) THEN
C
C      C'EST UNE VRAIE FACE DE BORD (LES FACES INTERNES EN PARALLELISME
C                                    SONT MARQUEES AVEC DES -2).
C      NUMEROS GLOBAUX DES POINTS DE LA FACE :
C
       I1 = IKLE( IELEM , SOMFAC(1,IFACE,KEL) )
       I2 = IKLE( IELEM , SOMFAC(2,IFACE,KEL) )
C
C      ON STOCKE DANS T1 ET T2 A L'ADRESSE I1 : I2 ET IELEM
C
       T1(I1) = I2
       T2(I1) = IELEM
C
C      UNE FACE LIQUIDE EST RECONNUE AVEC LA CONDITION LIMITE SUR H
C
C      07/02/03 IF(NPTFR...  COURTESY OLIVER GOETHEL, HANNOVER UNIVERSITY
       IF(NPTFR.GT.0) THEN
       IF(LIHBOR(T3(I1)).NE.KLOG.AND.LIHBOR(T3(I2)).NE.KLOG) THEN
C        FACE LIQUIDE : IFABOR=0  FACE SOLIDE : IFABOR=-1
         IFABOR(IELEM,IFACE)=0
       ENDIF
       ENDIF
C
      ENDIF
C
10    CONTINUE
20    CONTINUE
C
C  BOUCLE SUR TOUS LES POINTS:
C
C     07/02/03 IF(NPTFR...  CORRECTION BY OLIVER GOETHELS, HANNOVER
      IF(NPTFR.GT.0) THEN
      DO I = 1 , NPOIN
         IF(T1(I).NE.0) THEN
C          POINT SUIVANT
           KP1BOR(T3(I),1)=T3(T1(I))
C          POINT PRECEDENT
           KP1BOR(T3(T1(I)),2)=T3(I)
           NELBOR(T3(I))=T2(I)
         ENDIF
      ENDDO
      ENDIF
C
C CALCUL DU TABLEAU NULONE
C
      DO 50 K1=1,NPTFR
C
      K2=KP1BOR(K1,1)
      IEL = NELBOR(K1)
      N1  = NBOR(K1)
      N2  = NBOR(K2)
C
      I1 = 0
      I2 = 0
C
      DO 60 IPT=1,NPT
C
        IF(IKLE(IEL,IPT).EQ.N1) THEN
          NULONE(K1,1) = IPT
          I1 = 1
        ENDIF
        IF(IKLE(IEL,IPT).EQ.N2) THEN
          NULONE(K1,2) = IPT
          I2 = 1
        ENDIF
C
60    CONTINUE
C
      IF(I1.EQ.0.OR.I2.EQ.0) THEN
        IF(LNG.EQ.1) WRITE(LU,810) IEL
        IF(LNG.EQ.2) WRITE(LU,811) IEL
810     FORMAT(1X,'ELEBD: ERREUR DE NUMEROTATION DANS L''ELEMENT:',I15,/,
     *         1X,'       CAUSE POSSIBLE :                       '   ,/,
     *         1X,'       LE FICHIER DES CONDITIONS AUX LIMITES NE'  ,/,
     *         1X,'       CORRESPOND PAS AU FICHIER DE GEOMETRIE  ')
811     FORMAT(1X,'ELEBD: ERROR OF NUMBERING IN THE ELEMENT:',I15,
     *         1X,'       POSSIBLE REASON:                       '   ,/,
     *         1X,'       THE BOUNDARY CONDITION FILE IS NOT      '  ,/,
     *         1X,'       RELEVANT TO THE GEOMETRY FILE           ')
        CALL PARTEL_PARA_PLANTE2(-1)
        STOP
      ENDIF
C
50    CONTINUE
C
C  COMPLEMENT DU TABLEAU NBOR
C
      DO 80 K=1,NPTFR
C
        NBOR(K+NPTFR) = NBOR(KP1BOR(K,1))
C
        IKLBOR(K,1) = K
        IKLBOR(K,2) = KP1BOR(K,1)
C
80    CONTINUE
C
C-----------------------------------------------------------------------
C
      RETURN
      END
